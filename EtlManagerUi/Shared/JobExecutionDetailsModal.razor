@implements IDisposable

@inject IWebHostEnvironment WebHostEnvironment
@inject IDbContextFactory<EtlManagerContext> DbFactory
@inject IJSRuntime JS
@inject IConfiguration configuration
@inject IHttpContextAccessor HttpContextAccessor

<BSModal @ref="Modal" IsFullScreen="true" IsScrollable="true">
    <BSModalHeader @onclick="() => Modal.Hide()">@(Execution is not null ? Execution.JobName : null)</BSModalHeader>
    <BSModalBody>

        <BSButtonGroup IsToolbar="true">
            <BSButton Size="Size.Small" Color="Color.Primary" @onclick="LoadData" IsDisabled="Loading">
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/refresh-cw.svg")))
                Refresh
            </BSButton>

            <BSButton Size="Size.Small" Color="Color.Secondary" Class="ml-3" @onclick="() => JobExecutionDetailsOpen = !JobExecutionDetailsOpen">
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/info.svg")))
                Job details
            </BSButton>

            <BSButtonGroup Class="ml-3">
                <BSButton Size="Size.Small" Color="Color.Secondary" Class="@(ShowReport == Report.Table ? "active" : null)"
                          @onclick="() => ShowReport = Report.Table">
                    @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/bootstrap/table.svg")))
                    Table
                </BSButton>
                <BSButton Size="Size.Small" Color="Color.Secondary" Class="@(ShowReport == Report.Gantt ? "active" : null)"
                          @onclick="() => ShowReport = Report.Gantt">
                    @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/bootstrap/bar-chart-steps.svg")))
                    Gantt
                </BSButton>
                <BSButton Size="Size.Small" Color="Color.Secondary" Class="@(ShowReport == Report.Dependencies ? "active" : null)"
                            @onclick="() => { ShowReport = Report.Dependencies; }">
                    @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/bootstrap/diagram-3-fill.svg")))
                    Dependencies
                </BSButton>
            </BSButtonGroup>

            @if (Loading)
            {
                <div class="spinner-border text-primary align-middle ml-3" role="status">
                    <span class="sr-only">Loading...</span>
                </div>
            }
        </BSButtonGroup>

        <AuthorizeView Roles="Admin, Editor, Operator">
            @if (Execution is not null && Execution.ExecutionStatus == ExecutionStatus.Running)
            {
                <BSButtonGroup IsToolbar="true" Class="mt-3">
                    <BSDropdown>
                        <BSDropdownToggle Size="Size.Small" Color="Color.Danger" Class="@(Stopping ? "disabled" : null)">
                            @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/x-octagon.svg")))
                            Stop
                        </BSDropdownToggle>
                        <BSDropdownMenu>
                            <BSDropdownItem @onclick="StopJobExecutionAsync" IsDisabled="Stopping">Confirm</BSDropdownItem>
                        </BSDropdownMenu>
                    </BSDropdown>
                </BSButtonGroup>
            }
        </AuthorizeView>

        <div class="row my-1">
            <p></p>
        </div>

        @if (Execution is not null && JobExecutionDetailsOpen)
        {
            <dl class="row">
                <dt class="col-sm-3">
                    Execution id
                </dt>
                <dd class="col-sm-9">
                    @Execution.ExecutionId
                </dd>
                <dt class="col-sm-3">
                    Dependency mode
                </dt>
                <dd class="col-sm-9">
                    @Execution.DependencyMode
                </dd>
                @if (!Execution.DependencyMode)
                {
                    <dt class="col-sm-3">
                        Stop on first error
                    </dt>
                    <dd class="col-sm-9">
                        @Execution.StopOnFirstError
                    </dd>
                }
                <dt class="col-sm-3">
                    Max parallel steps
                </dt>
                <dd class="col-sm-9">
                    @Execution.MaxParallelSteps
                </dd>
                <dt class="col-sm-3">
                    Overtime notification limit (min)
                </dt>
                <dd class="col-sm-9">
                    @Execution.OvertimeNotificationLimitMinutes
                </dd>
                <dt class="col-sm-3">
                    Created by
                </dt>
                <dd class="col-sm-9">
                    @Execution.CreatedBy
                </dd>
                <dt class="col-sm-3">
                    Created
                </dt>
                <dd class="col-sm-9">
                    @Execution.CreatedDateTime.LocalDateTime
                </dd>
                <dt class="col-sm-3">
                    Started
                </dt>
                <dd class="col-sm-9">
                    @Execution.StartDateTime?.LocalDateTime
                </dd>
                <dt class="col-sm-3">
                    Ended
                </dt>
                <dd class="col-sm-9">
                    @Execution.EndDateTime?.LocalDateTime
                </dd>
                <dt class="col-sm-3">
                    Number of steps
                </dt>
                <dd class="col-sm-9">
                    @Execution.StepExecutions.Count
                </dd>
                <dt class="col-sm-3">
                    Success percent
                </dt>
                <dd class="col-sm-9">
                    @Execution.GetSuccessPercent().FormatPercentage(0)
                </dd>
                <dt class="col-sm-3">
                    Duration
                </dt>
                <dd class="col-sm-9">
                    <text>@Execution.GetDurationInReadableFormat()</text>
                </dd>
                <dt class="col-sm-3">
                    Status
                </dt>
                <dd class="col-sm-9">
                    <JobExecutionStatusBadgeComponent ExecutionStatus_="@Execution.ExecutionStatus" />
                </dd>
            </dl>
        }

        <div class="row">
            <div class="col">
                <small>Progress:</small>
                <div class="progress">
                    <div class="progress-bar @Execution?.ExecutionStatus.ToString().ToLower()" style="width: @($"{Execution?.GetProgressPercent() ?? 0}%");" />
                </div>
            </div>
        </div>

        @if (ShowReport == Report.Table || ShowReport == Report.Gantt)
        {
            <div class="row mt-3">
                <div class="col d-inline">
                    @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/filter.svg")))
                    <span class="mr-3">Filter</span>

                    <BSButtonGroup Size="Size.Small">
                        <FilterDropdown TItem="string"
                                        FilterSet="StepFilter"
                                        Items="Execution?.StepExecutions
                                .Where(s => !TagFilter.Any() || s.Step?.Tags.Any(t => TagFilter.Contains(t.TagName)) == true) // Limit visible steps based on tag filter
                                .Where(s => !StepStatusFilter.Any() || s.StepExecutionAttempts.Any(att =>
                                    StepStatusFilter.Contains(att.ExecutionStatus))) // Limit visible steps based on step status filter
                                .Where(s => !StepTypeFilter.Any() || StepTypeFilter.Contains(s.StepType)) // Limit visible steps based on step type filter
                                .Select(s => s.StepName)
                                .Distinct()
                                .OrderBy(j => j) ?? Enumerable.Empty<string>()"
                                        OnChange="StateHasChanged"
                                        IsSearchable="true">
                            <Title>
                                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/list.svg")))
                                Step
                            </Title>
                        </FilterDropdown>
                        <FilterDropdown TItem="StepType"
                                        FilterSet="StepTypeFilter"
                                        Items="Execution?.StepExecutions
                                .Where(s => !TagFilter.Any() || s.Step?.Tags.Any(t => TagFilter.Contains(t.TagName)) == true) // Limit visible step types based on tag filter
                                .Where(s => !StepStatusFilter.Any() || s.StepExecutionAttempts.Any(att =>
                                    StepStatusFilter.Contains(att.ExecutionStatus))) // Limit visible step types based on step status filter
                                .Where(s => !StepFilter.Any() || StepFilter.Contains(s.StepName)) // Limit visible step types based on step filter
                                .Select(s => s.StepType)
                                .Distinct()
                                .OrderBy(j => j) ?? Enumerable.Empty<StepType>()"
                                        OnChange="StateHasChanged">
                            <Title>
                                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/tool.svg")))
                                Step type
                            </Title>
                        </FilterDropdown>
                        <FilterDropdown TItem="StepExecutionStatus"
                                        FilterSet="StepStatusFilter"
                                        Items="Execution?.StepExecutions
                                .Where(s => !TagFilter.Any() || s.Step?.Tags.Any(t => TagFilter.Contains(t.TagName)) == true) // Limit visible step statuses based on tag filter
                                .Where(s => !StepFilter.Any() || StepFilter.Contains(s.StepName)) // Limit visible step statuses based on step filter
                                .Where(s => !StepTypeFilter.Any() || StepTypeFilter.Contains(s.StepType)) // Limit visible step statuses based on step type filter
                                .SelectMany(s => s.StepExecutionAttempts)
                                .Select(e => e.ExecutionStatus)
                                .Distinct()
                                .OrderBy(s => s) ?? Enumerable.Empty<StepExecutionStatus>()"
                                        OnChange="StateHasChanged">
                            <Title>
                                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/alert-circle.svg")))
                                Status
                            </Title>
                        </FilterDropdown>
                        <FilterDropdown TItem="string"
                                        FilterSet="TagFilter"
                                        Items="Execution?.StepExecutions
                                .Where(s => !StepFilter.Any() || StepFilter.Contains(s.StepName)) // Limit visible tags based on step filter
                                .Where(s => !StepTypeFilter.Any() || StepTypeFilter.Contains(s.StepType)) // Limit visible tags based on step type filter
                                .Where(s => !StepStatusFilter.Any() || s.StepExecutionAttempts.Any(att =>
                                            StepStatusFilter.Contains(att.ExecutionStatus))) // Limit visible tags based on step status filter
                                .SelectMany(e => e.Step?.Tags.Select(t => t.TagName) ?? Enumerable.Empty<string>())
                                .Distinct()
                                .OrderBy(s => s) ?? Enumerable.Empty<string>()"
                                        OnChange="StateHasChanged">
                            <Title>
                                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/tag.svg")))
                                Tag
                            </Title>
                        </FilterDropdown>
                        <BSButton Size="Size.Small" Color="Color.Light"
                                  @onclick="() => { StepStatusFilter.Clear(); StepFilter.Clear(); StepTypeFilter.Clear(); TagFilter.Clear(); }">
                            @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/x.svg")))
                            Reset
                        </BSButton>
                    </BSButtonGroup>
                </div>
            </div>
            <div class="row mt-3">
                <div class="col d-inline">
                    @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/list.svg")))
                    <span class="mr-3">Sort</span>
                    <div class="custom-control custom-radio custom-control-inline">
                        <input type="radio" class="custom-control-input" id="radio_started"
                               checked=@(SortMode_ == SortMode.Started)
                               @onchange="() => SortMode_ = SortMode.Started">
                        <label class="custom-control-label" for="radio_started">Started</label>
                    </div>
                    <div class="custom-control custom-radio custom-control-inline">
                        <input type="radio" class="custom-control-input" id="radio_duration"
                               checked=@(SortMode_ == SortMode.Duration)
                               @onchange="() => SortMode_ = SortMode.Duration">
                        <label class="custom-control-label" for="radio_duration">Duration</label>
                    </div>
                </div>
            </div>
        }

        @if (ShowReport == Report.Table)
        {
            <StepExecutionsTableComponent ShowDetailed="false"
                                          Executions="FilteredExecutions
                          .OrderByDescending(e => SortMode_ == SortMode.Duration ? e.ExecutionInSeconds : null)
                          .ThenBy(e => e.StartDateTime is null)
                          .ThenBy(e => e.StartDateTime)
                          .ThenBy(e => e.EndDateTime is null)
                          .ThenBy(e => e.EndDateTime)
                          .ThenBy(e => e.StepExecution.ExecutionPhase)
                          .ThenBy(e => e.StepExecution.StepName)" />
        }
        else if (ShowReport == Report.Gantt)
        {
            <StepExecutionsGraphComponent Executions="FilteredExecutions
                      .Where(e => e.StartDateTime != null)
                      .OrderByDescending(e => SortMode_ == SortMode.Duration ? e.ExecutionInSeconds : null)
                      .ThenBy(e => e.StartDateTime)
                      .ThenBy(e => e.StepExecution.StepName)" />
        }
        else if (ShowReport == Report.Dependencies)
        {
            if (Execution?.DependencyMode == false)
            {
                <BSAlert Color="Color.Warning" Class="mt-3">
                    Job is/was executed in execution phase mode. Dependencies have no effect.
                </BSAlert>
            }
        }

        <div class="container-fluid h-100 flex-column p-0 mt-3" hidden=@(ShowReport != Report.Dependencies)>
            <div class="row flex-fill dependency-graph border" id="div_dependency_graph">
                <svg id="svg_dependency_graph" viewBox="0 0 2000 1000">
                    <g id="g_dependency_graph" />
                </svg>
            </div>
        </div>
        @if (GraphWasRendered)
        {
            <div>
                @foreach (var step in Execution?.StepExecutions ?? Enumerable.Empty<StepExecution>())
                {
                    <BSTooltip Target="@step.StepId.ToString()" Placement="Placement.Top">
                        @step.GetExecutionStatus()
                        @step.GetDurationInSeconds().SecondsToReadableFormat()
                    </BSTooltip>
                }
            </div>
        }

        <StepExecutionDetailsModal @ref="StepExecutionDetailsModal" StepExecutionAttempt="SelectedStepExecutionAttempt" />

    </BSModalBody>
    <BSModalFooter>
        <BSButton Color="Color.Secondary" @onclick="() => Modal.Hide()">Close</BSButton>
    </BSModalFooter>
</BSModal>



@code {
    [Parameter]
    public string? ExecutionId_ { get; set; }

    private Guid ExecutionId => ExecutionId_ switch { not null => Guid.Parse(ExecutionId_), _ => Guid.Empty };

    private BSModal Modal { get; set; } = null!;

    private Execution? Execution { get; set; }

    private IEnumerable<StepExecutionAttempt> Executions =>
        Execution?.StepExecutions
        .SelectMany(e => e.StepExecutionAttempts)
        ?? Enumerable.Empty<StepExecutionAttempt>();

    private IEnumerable<StepExecutionAttempt> FilteredExecutions => Executions
        .Where(e => !TagFilter.Any() || e.StepExecution.Step?.Tags.Any(t => TagFilter.Contains(t.TagName)) == true)
        .Where(e => !StepStatusFilter.Any() || StepStatusFilter.Contains(e.ExecutionStatus))
        .Where(e => !StepFilter.Any() || StepFilter.Contains(e.StepExecution.StepName))
        .Where(e => !StepTypeFilter.Any() || StepTypeFilter.Contains(e.StepExecution.StepType));

    private Report ShowReport { get; set; } = Report.Table;

    private enum Report { Table, Gantt, Dependencies }

    private bool Loading { get; set; } = false;

    private bool JobExecutionDetailsOpen { get; set; } = false;

    private bool Stopping => StoppingExecutions.Any(id => id == ExecutionId);

    // Maintain a list executions that are being stopped.
    // This same component instance can be used to switch between different job executions.
    // This list allows for stopping multiple executions concurrently
    // and to modify the view based on which job execution is being shown.
    private List<Guid> StoppingExecutions { get; set; } = new();

    private HashSet<StepExecutionStatus> StepStatusFilter { get; } = new();
    private HashSet<string> StepFilter { get; } = new();
    private HashSet<StepType> StepTypeFilter { get; } = new();
    private HashSet<string> TagFilter { get; } = new();
    private SortMode SortMode_ { get; set; } = SortMode.Started;
    private enum SortMode { Started, Duration }

    private StepExecutionDetailsModal StepExecutionDetailsModal { get; set; } = null!;
    private StepExecutionAttempt? SelectedStepExecutionAttempt { get; set; }

    private DotNetObjectReference<MethodInvokeHelper> ObjectReference { get; set; } = null!;

    private bool GraphShouldRender { get; set; } = false;
    private bool GraphWasRendered { get; set; } = false;

    protected override void OnInitialized()
    {
        // Create a DotNetObjectReference with a new helper method tied to an instance of this component.
        // This will allow JS to call back to a specific instance of this component.
        // This needs to be done, because multiple users might be using this component concurrently.
        var helper = new MethodInvokeHelper(ShowStepExecutionModal);
        ObjectReference = DotNetObjectReference.Create(helper);
    }

    protected override async Task OnParametersSetAsync()
    {
        Execution = null;
        await LoadData();
    }

    private async Task LoadData()
    {
        if (ExecutionId != Guid.Empty)
        {
            Loading = true;
            using var context = DbFactory.CreateDbContext();

            GraphWasRendered = false;

            Execution = await context.Executions
                .AsNoTrackingWithIdentityResolution()
                .Include(e => e.ExecutionParameters)
                .Include(e => e.StepExecutions)
                .ThenInclude(e => e.StepExecutionAttempts)
                .Include(e => e.StepExecutions)
                .ThenInclude(e => e.ExecutionDependencies)
                .Include(e => e.StepExecutions)
                .ThenInclude(e => (e as ParameterizedStepExecution)!.StepExecutionParameters)
                .ThenInclude(p => p.ExecutionParameter)
                .Include(e => e.StepExecutions)
                .ThenInclude(e => e.Step)
                .ThenInclude(s => s!.Tags)
                .FirstOrDefaultAsync(e => e.ExecutionId == ExecutionId);
            StateHasChanged();
            Loading = false;

            GraphShouldRender = true;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (GraphShouldRender && ShowReport == Report.Dependencies)
            await LoadGraph();
    }

    private async Task LoadGraph()
    {
        GraphShouldRender = false;

        // Create a list of steps and dependencies and send them through JSInterop as JSON objects.
        var steps = Execution?.StepExecutions
            .Select(step =>
            {
                var status = step.GetExecutionStatus().ToString().ToLower();
                return new { Id = step.StepId, Name = step.StepName, ClassName = $"enabled {status}" };
            });
        var dependencies = Execution?.StepExecutions
            .SelectMany(step => step.ExecutionDependencies)
            .Select(dep => new { StepId = dep.StepId, DependantOnStepId = dep.DependantOnStepId, ClassName = dep.StrictDependency ? "strict" : "non-strict" });

        var stepsJson = JsonSerializer.Serialize(steps);
        var dependenciesJson = JsonSerializer.Serialize(dependencies);

        if (stepsJson is not null && dependenciesJson is not null)
            await JS.InvokeVoidAsync("drawDependencyGraph", stepsJson, dependenciesJson, ObjectReference);

        GraphWasRendered = true;
        StateHasChanged();
    }

    private void ShowStepExecutionModal(string text)
    {
        if (Guid.TryParse(text, out Guid id))
        {
            var step = Execution?.StepExecutions.First(s => s.StepId == id);
            var attempt = step?.StepExecutionAttempts.OrderByDescending(s => s.StartDateTime).First();
            SelectedStepExecutionAttempt = attempt;
            StateHasChanged();
            StepExecutionDetailsModal.Show();
        }
    }

    private async Task StopJobExecutionAsync()
    {
        if (Stopping)
        {
            await JS.InvokeVoidAsync("alert", "Execution is already stopping");
            return;
        }

        StoppingExecutions.Add(ExecutionId);
        try
        {
            string username = HttpContextAccessor.HttpContext?.User?.Identity?.Name
                ?? throw new ArgumentNullException(nameof(username), "Username cannot be null");
            await (Execution?.StopExecutionAsync(username) ?? Task.CompletedTask);
        }
        catch (TimeoutException)
        {
            await JS.InvokeVoidAsync("alert", "Operation timed out. The executor process may no longer be running.");
            StoppingExecutions.RemoveAll(id => id == ExecutionId);
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", "Error stopping execution:" + ex.Message);
            StoppingExecutions.RemoveAll(id => id == ExecutionId);
        }
    }

    private async Task StopStepExecutionAsync(StepExecutionAttempt stepExecution)
    {
        try
        {
            string username = HttpContextAccessor.HttpContext?.User?.Identity?.Name
                ?? throw new ArgumentNullException(nameof(username), "Username cannot be null");
            await stepExecution.StopExecutionAsync(username);
        }
        catch (TimeoutException)
        {
            await JS.InvokeVoidAsync("alert", "Operation timed out. The executor process may no longer be running.");
            StoppingExecutions.RemoveAll(id => id == ExecutionId);
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", "Error stopping execution:" + ex.Message);
            StoppingExecutions.RemoveAll(id => id == ExecutionId);
        }
    }

    public void Show() => Modal.Show();

    private DateTime MinTime => Executions.Any() ? Executions.Min(e => e.StartDateTime?.LocalDateTime) ?? DateTime.Now : DateTime.Now;
    private DateTime MaxTime => Executions.Any() ? Executions.Max(e => e.EndDateTime?.LocalDateTime ?? DateTime.Now) : DateTime.Now;
    private long MinTicks => MinTime.Ticks;
    private long MaxTicks => MaxTime.Ticks;

    private string GetTimeFromPercentage(int percentage)
    {
        if (MinTicks == MaxTicks)
            return DateTime.Now.ToString("HH:mm:ss");

        var ticks = MinTicks + (MaxTicks - MinTicks) * percentage / 100;
        var time = new DateTime(ticks);
        return time.ToString("HH:mm:ss");
    }

    private string GetDateFromPercentage(int percentage)
    {
        if (MinTicks == MaxTicks)
            return DateTime.Now.ToString("d");

        var ticks = MinTicks + (MaxTicks - MinTicks) * percentage / 100;
        var time = new DateTime(ticks);
        return time.ToString("d");
    }

    public void Dispose()
    {
        ObjectReference?.Dispose();
    }

}
