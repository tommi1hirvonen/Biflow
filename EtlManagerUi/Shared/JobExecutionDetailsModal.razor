@implements IDisposable

@inject IWebHostEnvironment WebHostEnvironment
@inject IDbContextFactory<EtlManagerContext> DbFactory
@inject IJSRuntime JS 
@inject IConfiguration configuration
@inject IHttpContextAccessor HttpContextAccessor

@*CSS styling for the vis-timeline object drawn using JSInterop in site.js*@
<style>
    .vis-item {
        cursor: pointer;
        font-weight: bold;
    }

    .vis-item .vis-item-overflow {
        overflow: visible;
    }

    .steps-graph .running,
    .steps-graph .running.vis-selected {
        background-color: @GetFillFromStatus("RUNNING");
        border-color: @GetFillFromStatus("RUNNING", true);
        color: @GetFillFromStatus("RUNNING", true);
    }
    .steps-graph .completed,
    .steps-graph .completed.vis-selected {
        background-color: @GetFillFromStatus("COMPLETED");
        border-color: @GetFillFromStatus("COMPLETED", true);
        color: @GetFillFromStatus("COMPLETED", true);
    }
    .steps-graph .failed,
    .steps-graph .failed.vis-selected {
        background-color: @GetFillFromStatus("FAILED");
        border-color: @GetFillFromStatus("FAILED", true);
        color: @GetFillFromStatus("FAILED", true);
    }
    .steps-graph .skipped,
    .steps-graph .skipped.vis-selected {
        background-color: @GetFillFromStatus("SKIPPED");
        border-color: @GetFillFromStatus("SKIPPED", true);
        color: @GetFillFromStatus("SKIPPED", true);
    }
    .steps-graph .stopped,
    .steps-graph .stopped.vis-selected {
        background-color: @GetFillFromStatus("STOPPED");
        border-color: @GetFillFromStatus("STOPPED", true);
        color: @GetFillFromStatus("STOPPED", true);
    }
    .steps-graph .duplicate,
    .steps-graph .duplicate.vis-selected {
        background-color: @GetFillFromStatus("DUPLICATE");
        border-color: @GetFillFromStatus("DUPLICATE", true);
        color: @GetFillFromStatus("DUPLICATE", true);
    }
    .steps-graph .await-retry,
    .steps-graph .await-retry.vis-selected {
        background-color: @GetFillFromStatus("AWAIT RETRY");
        border-color: @GetFillFromStatus("AWAIT RETRY", true);
        color: @GetFillFromStatus("AWAIT RETRY", true);
    }
</style>

<BSModal @ref="Modal" Size="Size.ExtraLarge" IsScrollable="true">
    <BSModalHeader @onclick="() => Modal.Hide()">@(JobExecution is not null ? JobExecution.JobName : null)</BSModalHeader>
    <BSModalBody>

        <BSButtonGroup IsToolbar="true">
            <BSButton Size="Size.Small" Color="Color.Primary" @onclick="LoadData" IsDisabled="Loading">
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/refresh-cw.svg")))
                Refresh
            </BSButton>

            <BSButton Size="Size.Small" Color="Color.Secondary" Class="ml-3" @onclick="() => JobExecutionDetailsOpen = !JobExecutionDetailsOpen">
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/info.svg")))
                Job details
            </BSButton>

            <BSButtonGroup Class="ml-3">
                <BSButton Size="Size.Small" Color="Color.Secondary" Class="@(ShowGraph ? "active" : null)"
                          @onclick="() => ShowGraph = true">
                    @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/bootstrap/bar-chart-steps.svg")))
                    Graph
                </BSButton>
                <BSButton Size="Size.Small" Color="Color.Secondary" Class="@(!ShowGraph ? "active" : null)"
                          @onclick="() => ShowGraph = false">
                    @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/bootstrap/table.svg")))
                    Table
                </BSButton>
            </BSButtonGroup>

            @if (Loading)
            {
                <div class="spinner-border text-primary align-middle ml-3" role="status">
                    <span class="sr-only">Loading...</span>
                </div>
            }
        </BSButtonGroup>

        <AuthorizeView Roles="Admin, Editor, Operator">
            @if (JobExecution is not null && JobExecution.ExecutionStatus == "RUNNING")
            {
                <BSButtonGroup IsToolbar="true" Class="mt-3">
                    <BSDropdown>
                        <BSDropdownToggle Size="Size.Small" Color="Color.Danger" Class="@(Stopping ? "disabled" : null)">
                            @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/x-octagon.svg")))
                            Stop
                        </BSDropdownToggle>
                        <BSDropdownMenu>
                            <BSDropdownItem @onclick="StopJobExecution" IsDisabled="Stopping">Confirm</BSDropdownItem>
                        </BSDropdownMenu>
                    </BSDropdown>
                    @if (Stopping)
                    {
                        <div class="spinner-border text-primary align-middle ml-3" role="status">
                            <span class="sr-only">Loading...</span>
                        </div>
                    }
                </BSButtonGroup>
            }
        </AuthorizeView>

        <div class="row my-1">
            <p></p>
        </div>

        @if (JobExecution is not null && JobExecutionDetailsOpen)
        {
            <dl class="row">
                <dt class="col-sm-3">
                    Execution id
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.ExecutionId
                </dd>
                <dt class="col-sm-3">
                    Dependency model
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.DependencyMode
                </dd>
                <dt class="col-sm-3">
                    Created by
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.CreatedBy
                </dd>
                <dt class="col-sm-3">
                    Created
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.CreatedDateTime
                </dd>
                <dt class="col-sm-3">
                    Started
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.StartDateTime
                </dd>
                <dt class="col-sm-3">
                    Ended
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.EndDateTime
                </dd>
                <dt class="col-sm-3">
                    Number of steps
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.NumberOfSteps
                </dd>
                <dt class="col-sm-3">
                    Success percent
                </dt>
                <dd class="col-sm-9">
                    @JobExecution.SuccessPercent.FormatPercentage(0)
                </dd>
                <dt class="col-sm-3">
                    Duration
                </dt>
                <dd class="col-sm-9">
                    <text>@JobExecution.GetDurationInReadableFormat()</text>
                </dd>
                <dt class="col-sm-3">
                    Status
                </dt>
                <dd class="col-sm-9">
                    <JobExecutionStatusBadgeComponent ExecutionStatus="@JobExecution.ExecutionStatus" />
                </dd>
            </dl>
        }

        @if (!ShowGraph)
        {
            <div class="form-inline">
                <div class="form-group">
                    <div class="input-group">
                        <div class="input-group-prepend">
                            <div class="input-group-text">
                                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/alert-circle.svg")))
                            </div>
                        </div>
                        <select class="form-control form-control-sm" @bind="StatusFilter">
                            <option value="" selected=@string.IsNullOrEmpty(StatusFilter)>ALL</option>
                            @if (Executions is not null)
                            {
                                @foreach (var status in Executions.Select(e => e.ExecutionStatus).Distinct().OrderBy(status => status))
                                {
                                    <option value="@status"
                                            selected=@(status == StatusFilter)>
                                        @status
                                    </option>
                                }
                            }
                        </select>
                    </div>
                </div>
            </div>
            <table class="table table-sm table-hover mt-2">
                <thead>
                    <tr>
                        @{ string Decorate(SortOption sortOption) => sortOption == SortOption_ ? "text-decoration: underline;" : null; }
                        <th>
                            <a style="@Decorate(SortOption.Name)" href="javascript:void(0)" @onclick="() => SortOption_ = SortOption.Name">
                                Step
                            </a>
                        </th>
                        <th>
                            Step type
                        </th>
                        <th>
                            <a style="@Decorate(SortOption.StartTime)" href="javascript:void(0)" @onclick="() => SortOption_ = SortOption.StartTime">
                                Started
                            </a>
                        </th>
                        <th>
                            <a style="@Decorate(SortOption.EndTime)" href="javascript:void(0)" @onclick="() => SortOption_ = SortOption.EndTime">
                                Ended
                            </a>
                        </th>
                        <th>
                            <a style="@Decorate(SortOption.Duration)" href="javascript:void(0)" @onclick="() => SortOption_ = SortOption.Duration">
                                Duration
                            </a>
                        </th>
                        <th>
                            <a style="@Decorate(SortOption.Status)" href="javascript:void(0)" @onclick="() => SortOption_ = SortOption.Status">
                                Status
                            </a>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    @if (Executions is null)
                    {
                        <tr><td colspan="6">Loading...</td></tr>
                    }
                    else if (Executions.Count == 0)
                    {
                        <tr><td colspan="6">No executions</td></tr>
                    }
                    else
                    {
                        @foreach (var item in Executions.Where(e => string.IsNullOrEmpty(StatusFilter) || e.ExecutionStatus == StatusFilter))
                        {
                            <tr class="@(SelectedStepExecution == item ? "bg-light" : null)" style="cursor: pointer;" @onclick="() => ToggleSelectedStepExecution(item)">
                                <td>
                                    @item.StepName
                                </td>
                                <td>
                                    <StepTypeIconComponent StepType="@item.StepType" />
                                </td>
                                <td>
                                    @item.StartDateTime
                                </td>
                                <td>
                                    @item.EndDateTime
                                </td>
                                <td>
                                    <text>@item.GetDurationInReadableFormat()</text>
                                </td>
                                <td>
                                    <StepExecutionStatusBadgeComponent ExecutionStatus="@item.ExecutionStatus" />
                                </td>
                            </tr>
                            @if (SelectedStepExecution == item)
                            {
                                <tr class="table-borderless">
                                    <td colspan="6" class="bg-light">
                                        <StepExecutionDetailsComponent StepExecution="item" />
                                    </td>
                                </tr>
                            }
                        }
                    }
                </tbody>
            </table>
        }

        <div class="steps-graph" id="steps_graph" hidden=@(!ShowGraph)>
        </div>

    </BSModalBody>
    <BSModalFooter>
        <BSButton Color="Color.Secondary" @onclick="() => Modal.Hide()">Close</BSButton>
    </BSModalFooter>
</BSModal>

<StepExecutionDetailsModal @ref="StepExecutionDetailsModal" StepExecution="SelectedStepExecutionModal" />

@code {
    [Parameter]
    public string ExecutionId_ { get; set; }

    private Guid ExecutionId => Guid.Parse(ExecutionId_);

    private BSModal Modal { get; set; }

    private JobExecution JobExecution { get; set; }

    private List<StepExecution> Executions { get; set; }

    private bool ShowGraph { get; set; } = false;

    private bool Loading { get; set; } = false;

    private bool JobExecutionDetailsOpen { get; set; } = false;

    private string StatusFilter { get; set; } = string.Empty;

    private StepExecution SelectedStepExecution { get; set; }

    private bool Stopping => StoppingExecutions.Any(id => id == ExecutionId);

    private SortOption _SortOption = SortOption.StartTime;
    private bool SortAscending = true;
    private SortOption SortOption_
    {
        get { return _SortOption; }
        set
        {
            if (value == _SortOption)
            {
                SortAscending = !SortAscending;
                Executions.Reverse();
            }
            else
            {
                SortAscending = true;
                _SortOption = value;
                SortExecutions();
            }
        }
    }

    // Maintain a list executions that are being stopped.
    // This same component instance can be used to switch between different job executions.
    // This list allows for stopping multiple executions concurrently
    // and to modify the view based on which job execution is being shown.
    private List<Guid> StoppingExecutions { get; set; } = new();

    private StepExecutionDetailsModal StepExecutionDetailsModal { get; set; }
    private StepExecution SelectedStepExecutionModal { get; set; }
    private DotNetObjectReference<MethodInvokeHelper> ObjectReference;

    protected override void OnInitialized()
    {
        // Create a DotNetObjectReference with a new helper method tied to an instance of this component.
        // This will allow JS to call back to a specific instance of this component.
        // This needs to be done, because multiple users might be using this component concurrently.
        var helper = new MethodInvokeHelper(ShowStepExecutionModal);
        ObjectReference = DotNetObjectReference.Create(helper);
    }

    protected override async Task OnParametersSetAsync()
    {
        JobExecution = null;
        Executions = null;
        await LoadData();
    }

    private async Task LoadData()
    {
        if (ExecutionId != Guid.Empty)
        {
            Loading = true;
            var context = DbFactory.CreateDbContext();

            JobExecution = await context.JobExecutions.FirstOrDefaultAsync(e => e.ExecutionId == ExecutionId);
            Executions = await context.Executions
                .Include(e => e.StepExecutionParameters)
                .Where(e => e.ExecutionId == ExecutionId)
                .ToListAsync();
            SortExecutions();
            StateHasChanged();
            Loading = false;

            // Create a JSON dataset that is passed to the JS method used to draw the steps graph via JSInterop.
            var dataset = Executions.Where(e => e.StartDateTime is not null).Select(e =>
            new
            {
                id = e.StepExecutionId,
                content = e.StepName,
                title = e.ExecutionStatus + ", " + e.GetDurationInReadableFormat(),
                className = e.ExecutionStatus.ToLower().Replace(' ', '-'),
                start = e.StartDateTime?.ToString("yyyy-MM-dd HH':'mm':'ss"),
                end = (e.EndDateTime ?? DateTime.Now).ToString("yyyy-MM-dd HH':'mm':'ss")
            }
            );
            var datasetJson = JsonSerializer.Serialize(dataset);
            await JS.InvokeVoidAsync("drawStepsTimeline", datasetJson, ObjectReference);
        }
    }

    private void SortExecutions()
    {
        if (SortAscending)
        {
            switch (SortOption_)
            {
                case SortOption.Duration:
                    Executions = Executions.OrderBy(e => e.ExecutionInSeconds).ThenBy(e => e.StepName).ToList();
                    break;
                case SortOption.StartTime:
                    // false sorts before true => not started steps are placed last
                    Executions = Executions.OrderBy(e => e.StartDateTime is null).ThenBy(e => e.StartDateTime)
                        .ThenBy(e => e.EndDateTime is null).ThenBy(e => e.EndDateTime)
                        .ThenBy(e => e.StepName).ToList();
                    break;
                case SortOption.EndTime:
                    Executions = Executions.OrderBy(e => e.EndDateTime).ThenBy(e => e.StepName).ToList();
                    break;
                case SortOption.Name:
                    Executions = Executions.OrderBy(e => e.StepName).ToList();
                    break;
                case SortOption.Status:
                    Executions = Executions.OrderBy(e => e.ExecutionStatus).ThenBy(e => e.StartDateTime).ThenBy(e => e.StepName).ToList();
                    break;
            }
        }
        else
        {
            switch (SortOption_)
            {
                case SortOption.Duration:
                    Executions = Executions.OrderByDescending(e => e.ExecutionInSeconds).ToList();
                    break;
                case SortOption.StartTime:
                    Executions = Executions.OrderByDescending(e => e.StartDateTime).ThenByDescending(e => e.EndDateTime).ToList();
                    break;
                case SortOption.EndTime:
                    Executions = Executions.OrderByDescending(e => e.EndDateTime).ThenByDescending(e => e.StartDateTime).ToList();
                    break;
                case SortOption.Name:
                    Executions = Executions.OrderByDescending(e => e.StepName).ToList();
                    break;
                case SortOption.Status:
                    Executions = Executions.OrderByDescending(e => e.ExecutionStatus).ToList();
                    break;
            }
        }
    }

    private void ToggleSelectedStepExecution(StepExecution execution)
    {
        SelectedStepExecution = SelectedStepExecution == execution ? null : execution;
        StateHasChanged();
    }

    private async Task StopJobExecution()
    {
        if (Stopping)
        {
            await JS.InvokeVoidAsync("alert", "Execution is already stopping");
            return;
        }

        StoppingExecutions.Add(ExecutionId);
        try
        {
            var username = HttpContextAccessor.HttpContext?.User?.Identity?.Name;
            await Utility.StopJobExecutionAsync(ExecutionId, username);
        }
        catch (TimeoutException)
        {
            await JS.InvokeVoidAsync("alert", "Operation timed out. The executor process may no longer be running.");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", "Error stopping execution:" + ex.Message);
        }
        StoppingExecutions.RemoveAll(id => id == ExecutionId);
        await LoadData();
    }

    private void ShowStepExecutionModal(string text)
    {
        var execution = Executions.FirstOrDefault(e => e.StepExecutionId == text);
        if (execution is not null)
        {
            SelectedStepExecutionModal = execution;
            StateHasChanged();
            StepExecutionDetailsModal.Show();
        }
    }

    public void Show() => Modal.Show();

    public void Dispose()
    {
        ObjectReference?.Dispose();
    }

    private enum SortOption
    {
        StartTime,
        EndTime,
        Duration,
        Name,
        Status
    }

    private static string colorRed = "#FEDEE5";
    private static string colorRedDark = "#823040";
    private static string colorGreen = "#CEF5EA";
    private static string colorGreenDark = "#056C4F";
    private static string colorOrange = "#FFF2CC";
    private static string colorOrangeDark = "#856200";
    private static string colorBlue = "#E3E5FD";
    private static string colorBlueDark = "#3B40A7";

    public static string GetFillFromStatus(string status, bool dark = false)
    {
        switch (status)
        {
            case "COMPLETED":
                return dark ? colorGreenDark : colorGreen;
            case "FAILED":
                return dark ? colorRedDark : colorRed;
            case "SKIPPED":
            case "STOPPED":
            case "DUPLICATE":
            case "AWAIT RETRY":
                return dark ? colorOrangeDark : colorOrange;
            case "RUNNING":
            default:
                return dark ? colorBlueDark : colorBlue;
        }
    }

}
