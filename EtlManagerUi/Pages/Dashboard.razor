@page "/dashboard"

@inject IDbContextFactory<EtlManagerContext> DbFactory
@inject IWebHostEnvironment WebHostEnvironment
@inject IJSRuntime JS 

<h4>Dashboard</h4>

<div class="btn-toolbar mt-3">
    <button type="submit" class="btn btn-sm btn-primary" @onclick="LoadData">
        @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/refresh-cw.svg")))
        Load report
    </button>
    @if (Loading)
    {
        <div class="spinner-border text-primary align-middle ml-3" role="status">
            <span class="sr-only">Loading...</span>
        </div>
    }
</div>

<div class="form-inline mt-3">
    <label>Date until:</label>
    <input @bind-value="DateTimeUntil" class="form-control form-control-sm ml-2" type="date">
    <label class="ml-5">Interval (d):</label>
    <input @bind-value="IntervalDays" class="form-control form-control-sm ml-2">
</div>

<div class="form-inline mt-3">
    <div class="custom-control custom-checkbox custom-control-inline">
        <input type="checkbox" class="custom-control-input" id="include_deleted" @bind-value="IncludeDeleted">
        <label class="custom-control-label" for="include_deleted">Include deleted jobs/steps</label>
    </div>
    <div class="custom-control custom-checkbox custom-control-inline ml-5">
        <input type="checkbox" class="custom-control-input" id="only_schedule" @bind-value="OnlyScheduled">
        <label class="custom-control-label" for="only_schedule">Only scheduled executions</label>
    </div>
</div>


<div class="container-fluid mt-4">
    <div class="row">
        <div class="card shadow-sm col-xl mr-xl-3 mb-xl-3 mb-3 pt-3">
            <h6>
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/clock.svg")))
                &nbsp;
                Average execution duration
            </h6>
            @if (!ReportLoaded)
            {
                <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
            }
            <canvas class="my-4 w-100" id="myChart1" width="900" height="380"></canvas>
        </div>
        <div class="card shadow-sm col-xl ml-xl-3 mb-xl-3 mt-xl-0 my-3 pt-3">
            <h6>
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/percent.svg")))
                &nbsp;
                Job success rate
            </h6>
            @if (!ReportLoaded)
            {
        <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
            }
            <canvas class="my-4 w-100" id="myChart2" width="900" height="380"></canvas>
        </div>
    </div>
    <div class="row">
        <div class="card shadow-sm col-xl mr-xl-3 mt-xl-3 my-3 pt-3">
            <h6>
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/activity.svg")))
                &nbsp;
                Number of executions
            </h6>
            @if (!ReportLoaded)
            {
                <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
            }
            <canvas class="my-4 w-100" id="myChart3" width="900" height="380"></canvas>
        </div>
        <div class="card shadow-sm col-xl ml-xl-3 mt-xl-3 my-3 pt-3">
            <h6>
                @((MarkupString)System.IO.File.ReadAllText(System.IO.Path.Combine(WebHostEnvironment.WebRootPath, "icons/feather/alert-octagon.svg")))
                &nbsp;
                Top 5 failing steps
            </h6>
            @if (!ReportLoaded)
            {
                <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
            }
            else
            {
                <div class="row mt-4">
                    <table class="table table-striped table-sm">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Step</th>
                                <th>Job</th>
                                <th>Success %</th>
                                <th># of executions</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (TopFailedSteps is not null)
                            {
                                @for (int i = 0; i < TopFailedSteps.Count; i++)
                                {
                                    <tr>
                                        <td>@(i + 1)</td>
                                        <td>
                                            @TopFailedSteps[i].StepName
                                        </td>
                                        <td>
                                            @TopFailedSteps[i].JobName
                                        </td>
                                        <td>@TopFailedSteps[i].SuccessPercent.FormatPercentage(2)</td>
                                        <td>@TopFailedSteps[i].NoOfExecutions</td>
                                    </tr>
                                }
                            }
                        </tbody>
                    </table>
                </div>
            }
        </div>
    </div>
</div>

@code {

    private Dictionary<string, List<TimeSeriesItem>> TimeSeriesItems { get; set; } = new Dictionary<string, List<TimeSeriesItem>>();

    private Dictionary<string, string> JobColors = new Dictionary<string, string>();
    private List<ReportingJob>? Jobs { get; set; }

    private List<TopStep>? TopFailedSteps { get; set; }

    private int IntervalDays { get; set; } = 90;

    private DateTime DateTimeUntil { get; set; } = DateTime.Now.Date.AddDays(1);

    private bool IncludeDeleted { get; set; } = false;

    private bool OnlyScheduled { get; set; } = false;

    private bool Loading { get; set; }

    private bool ReportLoaded { get; set; } = false;

    private const string ReportNotLoadedMessage = "Load report to show data.";
    private const string ReportNotLoadedClass = "text-secondary small font-italic";

    private async Task LoadData()
    {
        Loading = true;

        var context = DbFactory.CreateDbContext();

        var dateTimeStart = DateTimeUntil.AddDays(-IntervalDays);

        // Get duration executions
        var executionsQuery = context.Executions
            .Where(e => e.EndDateTime != null && e.CreatedDateTime >= dateTimeStart && e.CreatedDateTime < DateTimeUntil);

        if (!IncludeDeleted)
        {
            executionsQuery = executionsQuery.Where(e => context.Jobs.Where(job => job.JobId == e.JobId).Any());
        }

        if (OnlyScheduled)
        {
            executionsQuery = executionsQuery.Where(e => e.ScheduleId != null);
        }

        // Group job executions by job names to day level and calculate each job's average duration as well as the number of executions.
        var executions = await executionsQuery
            .OrderBy(e => e.CreatedDateTime).ToListAsync();
        var executions_ = executions.GroupBy(group => new
            {
                group.JobName,
                ((DateTimeOffset)group.CreatedDateTime.LocalDateTime).Date
            })
            .Select(select => new TimeSeriesItem
            {
                DurationInMinutes = select.Average(total => (decimal)(total.ExecutionInSeconds ?? 0) / 60),
                JobName = select.Key.JobName,
                Date = select.Key.Date,
                NumberOfExecutions = select.Count()
            });

        TimeSeriesItems = executions_
            .GroupBy(e => e.JobName)
            .ToDictionary(e => e.Key, e => e.ToList());


        // Job success rates
        var jobsQuery = context.Executions
            .Include(e => e.StepExecutions)
            .ThenInclude(e => e.StepExecutionAttempts)
            .Where(e => e.CreatedDateTime >= dateTimeStart && e.CreatedDateTime < DateTimeUntil);

        if (!IncludeDeleted)
        {
            jobsQuery = jobsQuery.Where(e => context.Jobs.Where(job => job.JobId == e.JobId).Any());
        }

        if (OnlyScheduled)
        {
            jobsQuery = jobsQuery.Where(e => e.ScheduleId != null);
        }

        // Group job executions by job name and calculate average success percentage.
        var jobs = await jobsQuery.ToListAsync();
        Jobs = jobs.GroupBy(group => group.JobName)
        .Select(select => new ReportingJob
        {
            SuccessPercent = select.Average(total => total.GetSuccessPercent()),
            JobName = select.Key
        })
        .OrderByDescending(order => order.SuccessPercent)
        .ToList();

        // Get a temporary list of all job names to retrieve their colors.
        var jobNames = Jobs.Select(job => job.JobName).Concat(TimeSeriesItems.Select(tsi => tsi.Key)).Distinct().OrderBy(name => name).ToList();
        JobColors = jobNames
            .Select((name, index) => new { Item = name, Index = index })
            .ToDictionary(elem => elem.Item, elem => colors[elem.Index % colors.Count]);


        // Get top failed steps
        var topFailedStepsQuery = context.StepExecutions
            .Include(e => e.StepExecutionAttempts)
            .Include(e => e.Execution)
            .Where(e => e.Execution.CreatedDateTime >= dateTimeStart && e.Execution.CreatedDateTime < DateTimeUntil);

        if (!IncludeDeleted)
        {
            topFailedStepsQuery = topFailedStepsQuery.Where(e => context.Steps.Where(step => step.StepId == e.StepId).Any());
        }

        if (OnlyScheduled)
        {
            topFailedStepsQuery = topFailedStepsQuery.Where(e => e.Execution.ScheduleId != null);
        }

        var topFailedStepsGrouping = await topFailedStepsQuery.ToListAsync();

        // Group step executions by step and job and calculate success percentages
        // based on the number of completed executions and the number of all executions.
        TopFailedSteps = topFailedStepsGrouping
            .GroupBy(group => new { group.StepId, group.StepName, group.Execution.JobId, group.Execution.JobName })
            .Select(select => new TopStep
            {
                StepName = select.Key.StepName,
                StepId = select.Key.StepId,
                JobName = select.Key.JobName,
                JobId = select.Key.JobId ?? Guid.Empty,
                NoOfExecutions = select.Count(),
                SuccessPercent = (decimal)select.Count(e => e.StepExecutionAttempts.Any(attempt => attempt.ExecutionStatus == StepExecutionStatus.Succeeded)) / select.Count() * 100
            })
            .OrderBy(order => order.SuccessPercent)
            .Where(e => e.SuccessPercent < 100)
            .Take(5)
            .ToList();

        // Create JSON dataset objects that are passed to the JS code in site.js via JSInterop.
        var durationDataset = TimeSeriesItems.Select((e, index) =>
        new
        {
            label = e.Key,
            fill = false,
            backgroundColor = JobColors[e.Key],
            borderColor = JobColors[e.Key],
            data = e.Value.Select(v => new { t = v.Date.ToString("yyyy-M-d")?.Replace('.', ':'), y = v.DurationInMinutes })
        });
        var durationDatasetJson = JsonSerializer.Serialize(durationDataset);

        var noOfExecutionsDataset = TimeSeriesItems.Select((e, index) =>
        new
        {
            label = e.Key,
            fill = false,
            backgroundColor = JobColors[e.Key],
            borderColor = JobColors[e.Key],
            data = e.Value.Select(v => new { t = v.Date.ToString("yyyy-M-d")?.Replace('.', ':'), y = v.NumberOfExecutions })
        });
        var noOfExecutionsJson = JsonSerializer.Serialize(noOfExecutionsDataset);

        var successRateDataset = Jobs.Select(job =>
        new
        {
            label = job.JobName,
            data = decimal.Round(job.SuccessPercent, 2),
            color = JobColors[job.JobName]
        }
        );
        var successRateDatasetJson = JsonSerializer.Serialize(successRateDataset);

        ReportLoaded = true;

        await JS.InvokeVoidAsync("drawDurationGraph", durationDatasetJson);
        await JS.InvokeVoidAsync("drawNoOfExecutionsGraph", noOfExecutionsJson);
        await JS.InvokeVoidAsync("drawSuccessRateGraph", successRateDatasetJson);

        Loading = false;
    }

    private List<string> colors = new List<string>
        {
            "#727cf5", // indigo
            "#0acf97", // teal
            "#007bff", // blue
            "#fa5c7c", // red
            "#ffc107", // yellow
            "#28a745", // green
            "#fd7e14", // orange
            "#17a2b8", // cyan
            "#e83e8c", // pink
            "#6f42c1" // purple
        };

    public class TimeSeriesItem
    {
        public string JobName { get; set; } = string.Empty;
        public DateTime Date { get; set; }
        public decimal DurationInMinutes { get; set; }
        public int NumberOfExecutions { get; set; }
    }

    public class ReportingJob
    {
        public decimal SuccessPercent { get; set; }
        public string JobName { get; set; } = string.Empty;
    }

    public class TopStep
    {
        public decimal SuccessPercent { get; set; }
        public string StepName { get; set; } = string.Empty;
        public Guid StepId { get; set; }
        public string JobName { get; set; } = string.Empty;
        public Guid JobId { get; set; }
        public int NoOfExecutions { get; set; }
    }

}
