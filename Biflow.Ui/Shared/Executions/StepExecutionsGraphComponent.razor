@using System.Globalization

@inject IHxMessengerService Messenger
@inject IHttpContextAccessor HttpContextAccessor
@inject IExecutorService ExecutorService
@inject IDbContextFactory<AppDbContext> DbContextFactory

<div class="row mx-1 my-2">
    <div class="col">
        <div class="row" style="height: 40px;">
            <div class="col-xl-3 col-lg-4 col-5 py-1 d-flex align-items-center justify-content-end">
            </div>
            <div class="col-xl-9 col-lg-8 col-7 d-flex align-items-center" style="position: relative;">
                @for (int i = 0; i <= Columns; i++)
                {
                    var percentage = i * 100.0 / Columns;
                    @*With screen sizes < xl only show every other line*@
                    <div class="@(i % 2 != 0 ? "d-none d-xl-flex" : "d-flex") align-items-center text-body-secondary"
                     style="height: 100%; border-left: 1px dashed var(--bs-border-color); position: absolute; left: @(percentage.ToString("F10", CultureInfo.InvariantCulture))%;">
                        @if (i < Columns)
                        {
                            <small>@GetDateFromPercentage(percentage)<br />@GetTimeFromPercentage(percentage)</small>
                        }
                    </div>
                }
            </div>
        </div>
        @if (Executions is not null)
        {
            var executions = Executions
                .Where(e => e.StartDateTime is not null)
                .GroupBy(e =>
                {
                    var overlapsWithSelf = Executions
                        .Where(other => other.StepId == e.StepId && e.ExecutionId != other.ExecutionId)
                        .Any(other => e.StartDateTime >= other.StartDateTime && e.StartDateTime <= (other.EndDateTime ?? DateTime.Now));
                    return (e.StepId, e.StepName, e.StepType, overlapsWithSelf ? e.ExecutionId : Guid.Empty);
                })
                .OrderBy(g => SortMode == SortMode.DurationAsc ? g.Max(e => e.ExecutionInSeconds) : null)
                .OrderByDescending(g => SortMode == SortMode.DurationDesc ? g.Max(e => e.ExecutionInSeconds) : null)
                .ThenBy(g => SortMode == SortMode.StartedAsc ? g.Min(e => e.StartDateTime) : null)
                .ThenByDescending(g => SortMode == SortMode.StartedDesc ? g.Min(e => e.StartDateTime) : null)
                .ToList();
            <Virtualize Context="group" Items="executions" ItemSize="32.5714f">
                <div class="row border-top">
                    <div class="col-xl-3 col-lg-4 col-5 text-end py-1">
                        <small>
                            @group.Key.StepName
                            &nbsp;
                            <StepTypeIconComponent StepType_="group.Key.StepType" />
                        </small>
                    </div>
                    <div class="col-xl-9 col-lg-8 col-7 d-flex align-items-center" style="position: relative;">
                        @for (int i = 0; i <= Columns; i++)
                        {
                            var percentage = i * 100.0 / Columns;
                            <div class="d-flex align-items-center" style="height: 100%; border-left: 1px dashed var(--bs-border-color); position: absolute; left: @(percentage.ToString("F10", CultureInfo.InvariantCulture))%;"></div>
                        }
                        @foreach (var execution in group)
                        {
                            (var offset, var width) = (execution.StartDateTime, execution.EndDateTime)
                                .GetGanttGraphDimensions(Executions.Select(e => (e.StartDateTime, e.EndDateTime)));
                            <div class="progress hover @(execution == SelectedStepExecution ? "active" : null) @execution.ExecutionStatus.ToString().ToLower()"
                                 style="cursor: pointer; position: absolute; width: @($"{width.ToString("F10", CultureInfo.InvariantCulture)}%"); left: @($"{offset.ToString("F10", CultureInfo.InvariantCulture)}%");"
                                 title="@($"{execution.ExecutionStatus}, {execution.ExecutionInSeconds?.SecondsToReadableFormat()}")"
                                 @onclick="() => ToggleSelectedStepExecutionAsync(execution)">
                                <div class="progress-bar" style="width: 100%;"></div>
                            </div>
                        }
                    </div>
                </div>
                @if (SelectedStepExecution is not null && group.Contains(SelectedStepExecution))
                {
                    if (DetailStep is null)
                    {
                        <div class="row bg-body-tertiary">
                            <div class="col text-center">
                                <HxSpinner Color="ThemeColor.Secondary" Size="SpinnerSize.Small" />
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="row bg-body-tertiary">
                            <div class="col">
                                <HxButtonToolbar CssClass="mb-3 mt-2 ms-2">
                                    <HxButton Size="ButtonSize.Small" Color="ThemeColor.None" CssClass="btn-auto" @onclick="() => ToggleSelectedStepExecutionAsync(SelectedStepExecution)">
                                        <CxIcon Icon="FeatherIcon.X" />
                                        Close
                                    </HxButton>
                                    <HxButton Size="ButtonSize.Small" Color="ThemeColor.None" CssClass="btn-auto ms-3" @onclick="async () => await StepHistoryOffcanvas.LetAsync(x => x.ShowAsync(DetailStep.StepId))">
                                        <CxIcon Icon="LucideIcon.History" />
                                        History
                                    </HxButton>
                                    <AuthorizeView Roles="@($"{Roles.Admin}, {Roles.Editor}, {Roles.Operator}")">
                                        @if (DetailStep.CanBeStopped)
                                        {
                                            <HxDropdownButtonGroup CssClass="ms-3">
                                                <HxDropdownToggleButton Size="ButtonSize.Small" Color="ThemeColor.None" CssClass="btn-auto text-danger">
                                                    <CxIcon Icon="FeatherIcon.XOctagon" />
                                                    Stop
                                                </HxDropdownToggleButton>
                                                <HxDropdownMenu>
                                                    <HxDropdownItem @onclick="() => StopStepExecutionAsync(DetailStep)">Confirm</HxDropdownItem>
                                                </HxDropdownMenu>
                                            </HxDropdownButtonGroup>
                                        }
                                    </AuthorizeView>
                                </HxButtonToolbar>

                                <StepExecutionDetailsComponent StepExecutionAttempt="DetailStep" ShowExtraDetails />
                        </div>
                    </div>
                    }
                }
            </Virtualize>
        }
    </div>
</div>

<StepHistoryOffcanvas @ref="StepHistoryOffcanvas" />

@code {
    [Parameter] public IEnumerable<StepExecutionProjection>? Executions { get; set; }

    [Parameter] public SortMode SortMode { get; set; } = SortMode.StartedAsc;

    [Parameter] public Func<StepExecutionProjection, StepExecutionAttempt?>? DetailStepProvider { get; set; }

    private const int Columns = 12;

    private StepExecutionProjection? SelectedStepExecution { get; set; }

    private StepHistoryOffcanvas? StepHistoryOffcanvas { get; set; }

    private StepExecutionAttempt? DetailStep { get; set; }

    private async Task ToggleSelectedStepExecutionAsync(StepExecutionProjection execution)
    {
        if (SelectedStepExecution == execution)
        {
            SelectedStepExecution = null;
            DetailStep = null;
        }
        else
        {
            SelectedStepExecution = execution;

            if (DetailStepProvider is not null)
            {
                DetailStep = DetailStepProvider(execution);
            }
            else
            {
                using var context = await DbContextFactory.CreateDbContextAsync();
                DetailStep = await context.StepExecutionAttempts
                    .AsNoTrackingWithIdentityResolution()
                    .Include($"{nameof(StepExecutionAttempt.StepExecution)}.{nameof(IHasStepExecutionParameters.StepExecutionParameters)}.{nameof(StepExecutionParameterBase.InheritFromExecutionParameter)}")
                    .Include($"{nameof(StepExecutionAttempt.StepExecution)}.{nameof(IHasStepExecutionParameters.StepExecutionParameters)}.{nameof(StepExecutionParameterBase.ExpressionParameters)}")
                    .Include(e => e.StepExecution)
                    .ThenInclude(e => e.Execution)
                    .ThenInclude(e => e.ExecutionParameters)
                    .Include(e => e.StepExecution)
                    .ThenInclude(e => e.ExecutionConditionParameters)
                    .ThenInclude(e => e.ExecutionParameter)
                    .Include(e => e.StepExecution)
                    .ThenInclude(e => e.Step)
                    .FirstOrDefaultAsync(e => e.ExecutionId == execution.ExecutionId && e.StepId == execution.StepId && e.RetryAttemptIndex == execution.RetryAttemptIndex);
            }
        }
        StateHasChanged();
    }

    private async Task StopStepExecutionAsync(StepExecutionAttempt stepExecution)
    {
        try
        {
            string username = HttpContextAccessor.HttpContext?.User?.Identity?.Name
                ?? throw new ArgumentNullException(nameof(username), "Username cannot be null");
            await ExecutorService.StopExecutionAsync(stepExecution.ExecutionId, stepExecution.StepId, username);
            if (stepExecution.ExecutionStatus == StepExecutionStatus.NotStarted)
            {
                Messenger.AddInformation("Stop request sent successfully to the executor service. The step will be stopped once it reaches the 'Queued' status.");
            }
            else
            {
                Messenger.AddInformation("Stop request sent successfully to the executor service");
            }
        }
        catch (TimeoutException)
        {
            Messenger.AddError("Operation timed out", "The executor process may no longer be running");
        }
        catch (Exception ex)
        {
            Messenger.AddError("Error stopping execution", ex.Message);
        }
    }

    private DateTime MinTime => Executions?.Any() ?? false ? Executions.Min(e => e.StartDateTime?.LocalDateTime) ?? DateTime.Now : DateTime.Now;
    private DateTime MaxTime => Executions?.Any() ?? false ? Executions.Max(e => e.EndDateTime?.LocalDateTime ?? DateTime.Now) : DateTime.Now;
    private long MinTicks => MinTime.Ticks;
    private long MaxTicks => MaxTime.Ticks;

    private string GetTimeFromPercentage(double percentage)
    {
        if (MinTicks == MaxTicks)
            return DateTime.Now.ToString("T");

        var ticks = MinTicks + (MaxTicks - MinTicks) * percentage / 100;
        var time = new DateTime(Convert.ToInt64(ticks));
        return time.ToString("T");
    }

    private string GetDateFromPercentage(double percentage)
    {
        if (MinTicks == MaxTicks)
            return DateTime.Now.ToString("d");

        var ticks = MinTicks + (MaxTicks - MinTicks) * percentage / 100;
        var time = new DateTime(Convert.ToInt64(ticks));
        return time.ToString("d");
    }

}
