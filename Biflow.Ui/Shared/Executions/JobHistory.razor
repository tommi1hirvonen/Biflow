@implements IDisposable

@inject IDbContextFactory<AppDbContext> DbFactory
@inject NavigationManager NavigationManager

@if (!string.IsNullOrEmpty(JobName))
{
    <PageTitle>@JobName | History | Biflow</PageTitle>
}

<div class="row">
    <div class="col-auto d-inline-flex align-items-center">
        <label>No of executions</label>
        <input @bind-value="_maxExecutions" class="form-control form-control-sm ms-3" type="number" style="max-width: 5rem;">
    </div>
    <div class="col-auto">
        <HxButton Color="ThemeColor.Primary" Size="ButtonSize.Small" OnClick="ReloadAsync">
            <SvgIcon Icon="LucideIcon.RefreshCw" />
            Refresh
        </HxButton>
    </div>
    <div class="col-auto">
        <HxButtonGroup Size="ButtonGroupSize.Small">
            <HxButton Size="ButtonSize.Small" Color="ThemeColor.Secondary" CssClass="@(_showChart ? null : "active")" OnClick="() => _showChart = false">
                <SvgIcon Icon="LucideIcon.List" />
                List
            </HxButton>
            <HxButton Size="ButtonSize.Small" Color="ThemeColor.Secondary" CssClass="@(_showChart ? "active" : null)" OnClick="() => _showChart = true">
                <SvgIcon Icon="LucideIcon.LineChart" />
                Chart
            </HxButton>
        </HxButtonGroup>
    </div>
    <div class="col-auto align-items-center d-flex">
        <div class="form-check form-check-inline">
            <input type="radio" class="form-check-input" id="radio_scheduled"
                    checked=@(_startTypeFilter == StartType.Scheduled)
                    @onchange="() => SetStartTypeFilter(StartType.Scheduled)">
            <label class="form-check-label" for="radio_scheduled">Scheduled</label>
        </div>
        <div class="form-check form-check-inline ms-2">
            <input type="radio" class="form-check-input" id="radio_manual"
                    checked=@(_startTypeFilter == StartType.Manual)
                    @onchange="() => SetStartTypeFilter(StartType.Manual)">
            <label class="form-check-label" for="radio_manual">Manual</label>
        </div>
        <div class="form-check form-check-inline ms-2">
            <input type="radio" class="form-check-input" id="radio_all"
                   checked=@(_startTypeFilter == StartType.All)
                    @onchange="() => SetStartTypeFilter(StartType.All)">
            <label class="form-check-label" for="radio_all">All</label>
        </div>
    </div>
</div>

<div class="row mt-1">
    <div class="col">
        <small class="text-muted">Actual no of executions: @_executions?.Count()</small>
    </div>
</div>

<div class="card pt-2 mb-4 mt-3 table-responsive">
    @if (!_showChart)
    {
        <table class="table table-sm table-hover">
            <thead>
                <tr>
                    <th>
                        Created/started
                    </th>
                    <th>
                        Ended
                    </th>
                    <th>
                        Duration
                    </th>
                    <th>
                        Number of steps
                    </th>
                    <th>
                        Status
                    </th>
                    <th>
                        Created by
                    </th>
                </tr>
                <tr>
                    <th></th>
                    <th></th>
                    <th></th>
                    <th><text>@AverageDurationInSeconds.SecondsToReadableFormat()</text></th>
                    <th></th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
                @{
                    var executions = FilteredExecutions.ToArray();
                }
                @if (_executions is null)
                {
                    <tr><td colspan="6" class="text-center"><HxSpinner Color="ThemeColor.Secondary" Size="SpinnerSize.Small" /></td></tr>
                }
                else if (!executions.Any())
                {
                    <tr>
                        <td colspan="6">
                            @{
                                RenderFragment renderFragment = _startTypeFilter switch
                                {
                                    StartType.All => @<span>No executions</span>,
                                    StartType.Scheduled => @<span>No <strong>scheduled</strong> executions</span>,
                                    StartType.Manual => @<span>No <strong>manual</strong> executions</span>,
                                    _ => @<span>No executions</span>
                                };
                            }
                            @renderFragment
                        </td>
                    </tr>
                }
                else
                {
                    @foreach (var item in FilteredExecutions)
                    {
                        var createdBy = item switch
                        {
                            { ScheduleName: { Length: > 0 } scheduleName } => scheduleName,
                            { CreatedBy: { Length: > 0 } username } => username,
                            _ => ""
                        };
                        <tr>
                            <td class="align-middle">
                                <a class="text-body" href="@($"executions/{item.ExecutionId}/list")">
                                    @(item.StartedOn?.LocalDateTime ?? item.CreatedOn.LocalDateTime)
                                </a>
                            </td>
                            <td class="align-middle">
                                @item.EndedOn?.LocalDateTime
                            </td>
                            <td class="align-middle">
                                <text>@item.ExecutionInSeconds?.SecondsToReadableFormat()</text>
                            </td>
                            <td class="align-middle">
                                @item.StepExecutionCount
                            </td>
                            <td class="align-middle">
                                <JobExecutionStatusBadge ExecutionStatus="@item.ExecutionStatus" />
                            </td>
                            <td class="align-middle small">
                                @createdBy
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    }
    else
    {
        <div class="mx-3 mb-3">
            <LineChart Dataset="_dataset" />
        </div>
    }
    
</div>

@code {
    [Parameter] public Guid JobId { get; set; }

    [Parameter] public string? JobName { get; set; }

    private const int DefaultMaxExecutions = 50;

    private readonly CancellationTokenSource _cts = new();

    private IEnumerable<ExecutionProjection>? _executions;
    private int _maxExecutions = DefaultMaxExecutions;
    private StartType _startTypeFilter = StartType.All;
    private bool _showChart = false;
    private LineChartDataset? _dataset;

    private IEnumerable<ExecutionProjection> FilteredExecutions =>
        _executions?
        .Where(e => _startTypeFilter == StartType.All ||
                    _startTypeFilter == StartType.Scheduled && e.ScheduleId is not null ||
                    _startTypeFilter == StartType.Manual && e.ScheduleId is null)
        ?? [];

    private double AverageDurationInSeconds =>
        (int)(FilteredExecutions.Where(e => e.ExecutionStatus == ExecutionStatus.Succeeded).Average(e => e.ExecutionInSeconds) ?? 0);

    protected override async Task OnParametersSetAsync()
    {
        if (_executions is null && JobId != Guid.Empty)
        {
            await ReloadAsync();
        }
    }

    private void SetStartTypeFilter(StartType startType)
    {
        _startTypeFilter = startType;
        CalculateChartDataset();
    }

    private async Task ReloadAsync()
    {
        await using var context = await DbFactory.CreateDbContextAsync();
        _executions = await context.Executions
            .AsNoTracking()
            .AsSingleQuery()
            .Where(e => e.JobId == JobId)
            .OrderByDescending(e => e.CreatedOn)
            .Take(_maxExecutions)
            .Select(e => new ExecutionProjection(
                e.ExecutionId,
                e.JobId,
                e.JobName,
                e.ScheduleId,
                e.ScheduleName,
                e.CreatedBy,
                e.CreatedOn,
                e.StartedOn,
                e.EndedOn,
                e.ExecutionStatus,
                e.StepExecutions.Count(),
                Array.Empty<TagProjection>()))
            .ToArrayAsync(_cts.Token);
        CalculateChartDataset();
        StateHasChanged();
    }

    private void CalculateChartDataset()
    {
        var dataPoints = FilteredExecutions
            .Where(e => e.StartedOn is not null)
            .GroupBy(e => DateOnly.FromDateTime(e.CreatedOn.LocalDateTime))
            .Select(grouping => new TimeSeriesDataPoint(grouping.Key, grouping.Average(total => (decimal)(total.ExecutionInSeconds ?? 0) / 60)))
            .ToArray();
        var series = new LineChartSeries[]
        {
            new("Avg. duration", dataPoints)
        };
        _dataset = new LineChartDataset(series, "min", 0);
    }

    public void Dispose()
    {
        _cts.Cancel();
        _cts.Dispose();
    }
}
