@implements IAsyncDisposable

@inject IJSRuntime JS
@inject IHxMessengerService Messenger
@inject IDbContextFactory<BiflowContext> DbFactory
@inject IHxMessageBoxService Confirmer

@*CSS definitions for the dependency graph nodes and paths created in site.js through JSInterop.*@
<style>
    html, body {
        height: 100%;
    }
</style>

<PageTitle>@Job?.JobName | Dependencies | Biflow</PageTitle>

@if (Job?.UseDependencyMode == false)
{
    <HxAlert Color="ThemeColor.Warning">
        Job is in execution phase mode. Dependencies will not be used during execution.
    </HxAlert>
}

<div class="row align-items-end mb-3">
    <div class="col-xl-5 col-lg-5 col-12">
        <HxAutosuggest  @bind-Value="StepFilter"
                        @bind-Value:after="LoadGraph"
                        DataProvider="ProvideSuggestions"
                        TextSelector="TextSelector"
                        MinimumLength="0"
                        Delay="1"
                        InputSize="InputSize.Small"
                        Placeholder="Filter step">
            <ItemTemplate Context="item">
                <StepTypeIconComponent StepType_="item.StepType" />
                @item.StepName
            </ItemTemplate>
            <EmptyTemplate>
                <span class="p-2">No matching steps</span>
            </EmptyTemplate>
        </HxAutosuggest>
    </div>
    <div class="col-xl-2 col-lg-3 col-5">
        <div class="form-group">
            <label class="form-label">Depth backwards</label>
            <HxPopover Trigger="PopoverTrigger.Hover" Html Content="@("<p>The depth of traversal backwards when drawing the dependency graph starting from the filtered step.</p><p>Available only when the graph has been filtered.</p><p>0 = no limit</p>")">
                <ChildContent>
                    <span style="cursor: pointer;">
                        <CxIcon Icon="FeatherIcon.Info" />
                    </span>
                </ChildContent>
            </HxPopover>
            <input class="form-control form-control-sm" type="number" @bind-value="FilterDepthBackwards" disabled=@(StepFilter is null) />
        </div>
    </div>
    <div class="col-xl-2 col-lg-3 col-5">
        <div class="form-group">
            <label class="form-label">Depth forwards</label>
            <HxPopover Trigger="PopoverTrigger.Hover" Html Content="@("<p>The depth of traversal forwards when drawing the dependency graph starting from the filtered step.</p><p>Available only when the graph has been filtered.</p><p>0 = no limit</p>")">
                <ChildContent>
                    <span style="cursor: pointer;">
                        <CxIcon Icon="FeatherIcon.Info" />
                    </span>
                </ChildContent>
            </HxPopover>
            <input class="form-control form-control-sm" type="number" @bind-value="FilterDepthForwards" disabled=@(StepFilter is null) />
        </div>
    </div>
    <div class="col-2">
        <HxButton Size="ButtonSize.Small" Color="ThemeColor.Secondary" OnClick="LoadGraph">
            Apply depth filters
        </HxButton>
    </div>

</div>

<div class="border" style="resize: both; overflow: hidden;">
    <div class="p-1 dependency-graph" id="div_dependency_graph">
        <svg id="svg_dependency_graph" viewBox="0 0 2000 1000">
            <g id="g_dependency_graph" />
        </svg>
    </div>
</div>

@foreach (var step in Steps ?? Enumerable.Empty<Step>())
{
    <div id="@($"{step.StepId}_dropdown")" class="dropdown position-absolute">
        <ul class="dependency-graph-dropdown-menu dropdown-menu">
            <li>
                <h6 class="dropdown-header">
                    <StepTypeIconComponent StepType_="step.StepType" />
                    @step.StepName
                </h6>
            </li>
            <li>
                <span class="dropdown-item" role="button" @onclick="async () => { StepFilter = step; await LoadGraph();}">
                    <CxIcon Icon="FeatherIcon.Filter" />
                    Limit graph to this
                </span>
            </li>
            <AuthorizeView Roles="Admin, Editor">
                <li>
                    <span class="dropdown-item" role="button" @onclick="() => OpenStepEditModalAsync(step)">
                        <CxIcon Icon="FeatherIcon.Edit2" />
                        Edit
                    </span>
                </li>
                <li>
                    @if (step.IsEnabled)
                    {
                        <span class="dropdown-item" role="button" @onclick="() => ToggleEnabled(step, false)">
                            <CxIcon Icon="FeatherIcon.ToggleLeft" />
                            Disable
                        </span>
                    }
                    else
                    {
                        <span class="dropdown-item" role="button" @onclick="() => ToggleEnabled(step, true)">
                            <CxIcon Icon="FeatherIcon.ToggleRight" />
                            Enable
                        </span>
                    }
                </li>
                <li>
                    <span class="dropdown-item" role="button" @onclick="() => DeleteStep(step)">
                        <CxIcon Icon="FeatherIcon.Trash2" />
                        Delete
                    </span>
                </li>
            </AuthorizeView>
            <li>
                <span class="dropdown-item" role="button" @onclick="() => StepHistoryOffcanvas.LetAsync(x => x.ShowAsync(step.StepId))">
                    <CxIcon Icon="LucideIcon.History" />
                    History
                </span>
            </li>
        </ul>
    </div>
}

<StepHistoryOffcanvas @ref="StepHistoryOffcanvas" />

<AuthorizeView Roles="Admin, Editor">
    <SqlStepEditModal @ref="StepEditModals[StepType.Sql]"
        Connections="SqlConnections"
        OnStepSubmit="OnStepSubmit" />
    <TabularStepEditModal @ref="StepEditModals[StepType.Tabular]"
        Connections="SqlConnections"
        AsConnections="AsConnections"
        OnStepSubmit="OnStepSubmit" />
    <DatasetStepEditModal @ref="StepEditModals[StepType.Dataset]"
        Connections="SqlConnections"
        AppRegistrations="AppRegistrations"
        OnStepSubmit="OnStepSubmit" />
    <ExeStepEditModal @ref="StepEditModals[StepType.Exe]"
        Connections="SqlConnections"
        OnStepSubmit="OnStepSubmit" />
    <JobStepEditModal @ref="StepEditModals[StepType.Job]"
        Connections="SqlConnections"
        Jobs="Jobs"
        OnStepSubmit="OnStepSubmit" />
    <PackageStepEditModal @ref="StepEditModals[StepType.Package]"
        Connections="SqlConnections"
        OnStepSubmit="OnStepSubmit" />
    <PipelineStepEditModal @ref="StepEditModals[StepType.Pipeline]"
        Connections="SqlConnections"
        PipelineClients="PipelineClients"
        OnStepSubmit="OnStepSubmit" />
    <FunctionStepEditModal @ref="StepEditModals[StepType.Function]"
        Connections="SqlConnections"
        FunctionApps="FunctionApps"
        OnStepSubmit="OnStepSubmit" />
    <AgentJobStepEditModal @ref="StepEditModals[StepType.AgentJob]"
        Connections="SqlConnections"
        OnStepSubmit="OnStepSubmit" />
    <EmailStepEditModal @ref="StepEditModals[StepType.Email]"
        Connections="SqlConnections"
        OnStepSubmit="OnStepSubmit" />
</AuthorizeView>

@code {
    [CascadingParameter] public List<Job> Jobs { get; set; } = null!;

    [CascadingParameter] public Job? Job { get; set; }

    [CascadingParameter] public List<Step>? Steps { get; set; }

    [Parameter] public List<SqlConnectionInfo>? SqlConnections { get; set; }

    [Parameter] public List<AnalysisServicesConnectionInfo>? AsConnections { get; set; }

    [Parameter] public List<PipelineClient>? PipelineClients { get; set; }

    [Parameter] public List<AppRegistration>? AppRegistrations { get; set; }

    [Parameter] public List<FunctionApp>? FunctionApps { get; set; }

    [Parameter] public Guid? InitialStepId { get; set; }

    private Dictionary<StepType, IStepEditModal?> StepEditModals = new();

    private StepHistoryOffcanvas? StepHistoryOffcanvas { get; set; }

    private Step? StepFilter { get; set; }

    private int FilterDepthBackwards
    {
        get => _filterDepthBackwards;
        set => _filterDepthBackwards = value >= 0 ? value : _filterDepthBackwards;
    }

    private int _filterDepthBackwards;

    private int FilterDepthForwards
    {
        get => _filterDepthForwards;
        set => _filterDepthForwards = value >= 0 ? value : _filterDepthForwards;
    }

    private int _filterDepthForwards;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (InitialStepId is Guid filterStepId)
            {
                StepFilter = Steps?.FirstOrDefault(s => s.StepId == filterStepId);
                StateHasChanged();
            }
            await LoadGraph();
            await JS.InvokeVoidAsync("attachDependencyGraphBodyListener");
        }
    }

    private async Task LoadGraph()
    {
        string? stepsJson = null;
        string? dependenciesJson = null;

        ArgumentNullException.ThrowIfNull(Steps);

        if (StepFilter is null)
        {
            // Create a list of steps and dependencies and send them through JSInterop as JSON objects.
            var steps = Steps.Select(step => new
            {
                Id = step.StepId,
                Name = step.StepName,
                ClassName = step.IsEnabled ? "enabled" : "disabled",
                Tooltip = $"{step.StepType}"
            });
            var dependencies = Steps
                .SelectMany(step => step.Dependencies)
                .Select(dep => new
                {
                    StepId = dep.StepId,
                    DependantOnStepId = dep.DependantOnStepId,
                    ClassName = dep.DependencyType.ToString().ToLower()
                });

            stepsJson = JsonSerializer.Serialize(steps);
            dependenciesJson = JsonSerializer.Serialize(dependencies);
        }
        else
        {
            var startStep = Steps.FirstOrDefault(s => s.StepId == StepFilter.StepId);
            if (startStep is not null)
            {
                var steps = RecurseDependenciesBackward(startStep, new(), 0);
                steps.Remove(startStep);
                steps = RecurseDependenciesForward(startStep, steps, 0);

                var dependencies = steps
                    .SelectMany(step => step.Dependencies)
                    .Where(d => steps.Any(s => d.DependantOnStepId == s.StepId) && steps.Any(s => d.StepId == s.StepId)) // only include dependencies whose step is included
                    .Select(dep => new
                    {
                        StepId = dep.StepId,
                        DependantOnStepId = dep.DependantOnStepId,
                        ClassName = dep.DependencyType.ToString().ToLower()
                    });

                stepsJson = JsonSerializer.Serialize(steps.Select(step => new
                {
                    Id = step.StepId,
                    Name = step.StepName,
                    ClassName = step.IsEnabled ? "enabled" : "disabled",
                    Tooltip = $"{step.StepType}"
                }));
                dependenciesJson = JsonSerializer.Serialize(dependencies);
            }
        }

        if (stepsJson is not null && dependenciesJson is not null)
            await JS.InvokeVoidAsync("drawDependencyGraph", stepsJson, dependenciesJson);
    }

    private List<Step> RecurseDependenciesBackward(Step step, List<Step> processedSteps, int depth)
    {
        ArgumentNullException.ThrowIfNull(Steps);

        // If the step was already handled, return.
        // This way we do not loop indefinitely in case of circular dependencies.
        if (processedSteps.Any(s => s.StepId == step.StepId))
        {
            return processedSteps;
        }

        if (depth++ > FilterDepthBackwards && FilterDepthBackwards > 0)
        {
            depth--;
            return processedSteps;
        }

        processedSteps.Add(step);

        // Get dependency steps.
        List<Step> dependencySteps = Steps.Where(s => step.Dependencies.Any(d => s.StepId == d.DependantOnStepId)).ToList();

        // Loop through the dependencies and handle them recursively.
        foreach (var depencyStep in dependencySteps)
        {
            RecurseDependenciesBackward(depencyStep, processedSteps, depth);
        }

        depth--;

        return processedSteps;
    }

    private List<Step> RecurseDependenciesForward(Step step, List<Step> processedSteps, int depth)
    {
        ArgumentNullException.ThrowIfNull(Steps);
        if (processedSteps.Any(s => s.StepId == step.StepId))
        {
            return processedSteps;
        }

        if (depth++ > FilterDepthForwards && FilterDepthForwards > 0)
        {
            depth--;
            return processedSteps;
        }

        processedSteps.Add(step);

        List<Step> dependencySteps = Steps.Where(s => s.Dependencies.Any(d => d.DependantOnStepId == step.StepId)).ToList();

        foreach (var depencyStep in dependencySteps)
        {
            RecurseDependenciesForward(depencyStep, processedSteps, depth);
        }

        depth--;

        return processedSteps;
    }

    private Task OpenStepEditModalAsync(Step step) =>
        StepEditModals[step.StepType].LetAsync(x => x.ShowAsync(step.StepId, StepEditModalView.Dependencies));

    private async Task OnStepSubmit(Step step)
    {
        ArgumentNullException.ThrowIfNull(Steps);
        var existingStep = Steps.FirstOrDefault(s => s.StepId == step.StepId);
        if (existingStep is not null)
        {
            Steps.Remove(existingStep);
        }
        Steps.Add(step);
        SortSteps();
        await LoadGraph();
        StateHasChanged();
    }

    private async Task ToggleEnabled(Step step, bool value)
    {
        try
        {
            using var context = DbFactory.CreateDbContext();
            context.Attach(step);
            step.IsEnabled = value;
            await context.SaveChangesAsync();
            await LoadGraph();
        }
        catch (Exception ex)
        {
            Messenger.AddError("Error toggling step", ex.Message);
        }
    }

    private async Task DeleteStep(Step step)
    {
        var result = await Confirmer.ConfirmAsync($"Are you sure you want to delete step \"{step.StepName}\"?");
        if (!result)
        {
            return;    
        }

        try
        {
            using var context = DbFactory.CreateDbContext();
            context.Steps.Remove(step);
            await context.SaveChangesAsync();
            Steps?.Remove(step);

            // Remove the deleted step from dependencies.
            foreach (var dependant in Steps?.Where(s => s.Dependencies.Any(d => d.DependantOnStepId == step.StepId)) ?? Enumerable.Empty<Step>())
            {
                var dependency = dependant.Dependencies.First(d => d.DependantOnStepId == step.StepId);
                dependant.Dependencies.Remove(dependency);
            }

            await LoadGraph();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Messenger.AddError("Error deleting step", ex.Message);
        }
    }

    private void SortSteps()
    {
        if (Job is null || Steps is null) return;
        try
        {
            if (Job.UseDependencyMode)
            {
                var comparer = new TopologicalStepComparer(Steps);
                Steps.Sort(comparer);
            }
            else
            {
                Steps.Sort();
            }
        }
        catch (Exception ex)
        {
            Messenger.AddError("Error sorting steps", ex.Message);
        }
    }

    private async Task<AutosuggestDataProviderResult<Step>> ProvideSuggestions(AutosuggestDataProviderRequest request)
    {
        ArgumentNullException.ThrowIfNull(Steps);
        await Task.Delay(100);
        var filteredModules = Steps.Where(s => s.StepName?.ContainsIgnoreCase(request.UserInput) ?? false);
        return new AutosuggestDataProviderResult<Step>
        {
            Data = filteredModules
        };
    }

    private string TextSelector(Step step) => step.StepName ?? "";

    public async ValueTask DisposeAsync()
    {
        await JS.InvokeVoidAsync("disposeDependencyGraphBodyListener");
    }

}
