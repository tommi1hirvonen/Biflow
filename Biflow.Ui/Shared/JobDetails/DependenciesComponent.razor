@implements IDisposable

@inject IJSRuntime JS
@inject MarkupHelperService MarkupHelper
@inject IHxMessengerService Messenger

@*CSS definitions for the dependency graph nodes and paths created in site.js through JSInterop.*@
<style>
    html, body {
        height: 100%;
    }
</style>

<PageTitle>@Job?.JobName | Dependencies | Biflow</PageTitle>

@if (Job?.UseDependencyMode == false)
{
    <HxAlert Color="ThemeColor.Warning">
        Job is in execution phase mode. Dependencies will not be used during execution.
    </HxAlert>
}

<div class="row mb-3">
    <div class="col-xl-6 col-lg-8 col-md-10">
        <HxAutosuggest  TItem="Step"
                        TValue="Guid"
                        DataProvider="ProvideSuggestions"
                        ValueSelector="ValueSelector"
                        ItemFromValueResolver="ResolveAutosuggestItemFromValue"
                        TextSelector="TextSelector"
                        MinimumLength="0"
                        Delay="1"
                        InputSize="InputSize.Small"
                        ValueChanged="LimitGraph"
                        ValueExpression="() => StepFilter"
                        Placeholder="Filter step">
            <ItemTemplate Context="item">
                <StepTypeIconComponent StepType_="item.StepType" />
                @item.StepName
            </ItemTemplate>
            <EmptyTemplate>
                <span class="p-2">No matching steps</span>
            </EmptyTemplate>
        </HxAutosuggest>
    </div>
</div>

<div class="container-fluid h-100 flex-column p-0">
    <div class="row flex-fill dependency-graph border" id="div_dependency_graph">
        <svg id="svg_dependency_graph" viewBox="0 0 2000 1000">
            <g id="g_dependency_graph" />
        </svg>
    </div>
</div>

<AuthorizeView Roles="Admin, Editor">
    <SqlStepEditModal @ref="StepEditModals[StepType.Sql]" Job="Job" Steps="Steps" Connections="SqlConnections" StepId="EditModalStepIds[StepType.Sql]" OnStepSubmit="OnStepSubmit" />
    <TabularStepEditModal @ref="StepEditModals[StepType.Tabular]" Job="Job" Steps="Steps" Connections="SqlConnections" AsConnections="AsConnections" StepId="EditModalStepIds[StepType.Tabular]" OnStepSubmit="OnStepSubmit" />
    <DatasetStepEditModal @ref="StepEditModals[StepType.Dataset]" Job="Job" Steps="Steps" Connections="SqlConnections" AppRegistrations="AppRegistrations" StepId="EditModalStepIds[StepType.Dataset]" OnStepSubmit="OnStepSubmit" />
    <ExeStepEditModal @ref="StepEditModals[StepType.Exe]" Job="Job" Steps="Steps" Connections="SqlConnections" StepId="EditModalStepIds[StepType.Exe]" OnStepSubmit="OnStepSubmit" />
    <JobStepEditModal @ref="StepEditModals[StepType.Job]" Job="Job" Steps="Steps" Connections="SqlConnections" StepId="EditModalStepIds[StepType.Job]" Jobs="Jobs" OnStepSubmit="OnStepSubmit" />
    <PackageStepEditModal @ref="StepEditModals[StepType.Package]" Job="Job" Steps="Steps" Connections="SqlConnections" StepId="EditModalStepIds[StepType.Package]" OnStepSubmit="OnStepSubmit" />
    <PipelineStepEditModal @ref="StepEditModals[StepType.Pipeline]" Job="Job" Steps="Steps" Connections="SqlConnections" DataFactories="DataFactories" StepId="EditModalStepIds[StepType.Pipeline]" OnStepSubmit="OnStepSubmit" />
    <FunctionStepEditModal @ref="StepEditModals[StepType.Function]" Job="Job" Steps="Steps" Connections="SqlConnections" StepId="EditModalStepIds[StepType.Function]" FunctionApps="FunctionApps" OnStepSubmit="OnStepSubmit" />
    <AgentJobStepEditModal @ref="StepEditModals[StepType.AgentJob]" Job="Job" Steps="Steps" Connections="SqlConnections" StepId="EditModalStepIds[StepType.AgentJob]" OnStepSubmit="OnStepSubmit" />
</AuthorizeView>

@code {
    [Parameter]
    public List<Job> Jobs { get; set; } = null!;

    [Parameter]
    public Job? Job { get; set; }

    private Job? PrevJob { get; set; }

    [Parameter]
    public List<Step> Steps { get; set; } = null!;

    [Parameter]
    public List<SqlConnectionInfo>? SqlConnections { get; set; }
    [Parameter]
    public List<AnalysisServicesConnectionInfo>? AsConnections { get; set; }
    [Parameter]
    public List<DataFactory>? DataFactories { get; set; }
    [Parameter]
    public List<AppRegistration>? AppRegistrations { get; set; }
    [Parameter]
    public List<FunctionApp>? FunctionApps { get; set; }

    private DotNetObjectReference<MethodInvokeHelper> ObjectReference { get; set; } = null!;

    private Dictionary<StepType, IStepEditModal> StepEditModals = new();
    // Separate edit modal step ids so that changes to one do not trigger OnParametersSet() for all edit modal components.
    private Dictionary<StepType, Guid> EditModalStepIds { get; set; } = Enum.GetValues<StepType>().ToDictionary(key => key, _ => new Guid());

    private bool GrapShouldRender { get; set; }

    private Guid StepFilter { get; set; }

    protected override void OnInitialized()
    {
        // Create a DotNetObjectReference with a new helper method tied to an instance of this component.
        // This will allow JS to call back to a specific instance of this component.
        // This needs to be done, because multiple users might be using this component concurrently.
        var helper = new MethodInvokeHelper(OpenStepEditModal);
        ObjectReference = DotNetObjectReference.Create(helper);
    }

    protected override void OnParametersSet()
    {
        if (Job != PrevJob)
        {
            PrevJob = Job;
            StepFilter = Guid.Empty;
            StateHasChanged();
            GrapShouldRender = true;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (GrapShouldRender)
            await LoadGraph();
    }

    private async Task LoadGraph()
    {
        GrapShouldRender = false;
        string? stepsJson = null;
        string? dependenciesJson = null;

        if (StepFilter == Guid.Empty)
        {
            // Create a list of steps and dependencies and send them through JSInterop as JSON objects.
            var steps = Steps.Select(step => new
            {
                Id = step.StepId,
                Name = step.StepName,
                ClassName = step.IsEnabled ? "enabled" : "disabled",
                Tooltip = $"{step.StepType}"
            });
            var dependencies = Steps
                .SelectMany(step => step.Dependencies)
                .Select(dep => new
                {
                    StepId = dep.StepId,
                    DependantOnStepId = dep.DependantOnStepId,
                    ClassName = dep.StrictDependency ? "strict" : "non-strict"
                });

            stepsJson = JsonSerializer.Serialize(steps);
            dependenciesJson = JsonSerializer.Serialize(dependencies);
        }
        else
        {
            var startStep = Steps.FirstOrDefault(s => s.StepId == StepFilter);
            if (startStep is not null)
            {
                var steps = RecurseDependenciesBackward(startStep, new());
                steps.Remove(startStep);
                steps = RecurseDependenciesForward(startStep, steps);

                var dependencies = steps
                    .SelectMany(step => step.Dependencies)
                    .Where(d => steps.Any(s => d.DependantOnStepId == s.StepId) && steps.Any(s => d.StepId == s.StepId)) // only include dependencies whose step is included
                    .Select(dep => new
                    {
                        StepId = dep.StepId,
                        DependantOnStepId = dep.DependantOnStepId,
                        ClassName = dep.StrictDependency ? "strict" : "non-strict"
                    });

                stepsJson = JsonSerializer.Serialize(steps.Select(step => new
                {
                    Id = step.StepId,
                    Name = step.StepName,
                    ClassName = step.IsEnabled ? "enabled" : "disabled",
                    Tooltip = $"{step.StepType}"
                }));
                dependenciesJson = JsonSerializer.Serialize(dependencies);
            }
        }

        if (stepsJson is not null && dependenciesJson is not null)
            await JS.InvokeVoidAsync("drawDependencyGraph", stepsJson, dependenciesJson, ObjectReference);
    }

    private List<Step> RecurseDependenciesBackward(Step step, List<Step> processedSteps)
    {
        // If the step was already handled, return.
        // This way we do not loop indefinitely in case of circular dependencies.
        if (processedSteps.Any(s => s.StepId == step.StepId))
        {
            return processedSteps;
        }

        processedSteps.Add(step);

        // Get dependency steps.
        List<Step> dependencySteps = Steps.Where(s => step.Dependencies.Any(d => s.StepId == d.DependantOnStepId)).ToList();

        // Loop through the dependencies and handle them recursively.
        foreach (var depencyStep in dependencySteps)
        {
            RecurseDependenciesBackward(depencyStep, processedSteps);
        }

        return processedSteps;
    }

    private List<Step> RecurseDependenciesForward(Step step, List<Step> processedSteps)
    {
        if (processedSteps.Any(s => s.StepId == step.StepId))
        {
            return processedSteps;
        }

        processedSteps.Add(step);

        List<Step> dependencySteps = Steps.Where(s => s.Dependencies.Any(d => d.DependantOnStepId == step.StepId)).ToList();

        foreach (var depencyStep in dependencySteps)
        {
            RecurseDependenciesForward(depencyStep, processedSteps);
        }

        return processedSteps;
    }

    private async Task LimitGraph(Guid value)
    {
        StepFilter = value;
        GrapShouldRender = true;
        await LoadGraph();
    }

    // Step edit modals can be opened from JS using JSInterop by calling this method. See site.js => drawDependencyGraph().
    private void OpenStepEditModal(string id)
    {
        var stepId = Guid.Parse(id);
        var step = Steps.First(s => s.StepId == stepId);
        EditModalStepIds[step.StepType] = stepId;
        StateHasChanged();
        StepEditModals[step.StepType].ShowAsync(StepEditModalView.Dependencies);
    }

    private async Task OnStepSubmit(Step step)
    {
        var existingStep = Steps.FirstOrDefault(s => s.StepId == step.StepId);
        if (existingStep is not null)
        {
            Steps.Remove(existingStep);
        }
        Steps.Add(step);
        SortSteps();
        GrapShouldRender = true;
        await LoadGraph();
        StateHasChanged();
    }

    private void SortSteps()
    {
        if (Job is null || Steps is null) return;
        try
        {
            if (Job.UseDependencyMode)
            {
                var comparer = new TopologicalStepComparer(Steps);
                Steps.Sort(comparer);
            }
            else
            {
                Steps.Sort();
            }
        }
        catch (Exception ex)
        {
            Messenger.AddError("Error sorting steps", ex.Message);
        }
    }

    private async Task<AutosuggestDataProviderResult<Step>> ProvideSuggestions(AutosuggestDataProviderRequest request)
    {
        await Task.Delay(100);
        var filteredModules = Steps.Where(s => s.StepName?.ContainsIgnoreCase(request.UserInput) ?? false);
        return new AutosuggestDataProviderResult<Step>
        {
            Data = filteredModules
        };
    }

    private Guid ValueSelector(Step step) => step.StepId;

    private string TextSelector(Step step) => step.StepName ?? "";

    private Task<Step> ResolveAutosuggestItemFromValue(Guid value)
    {
        var step = Task.FromResult(Steps.First(step => step.StepId == value));
        return step;
    }

    public void Dispose()
    {
        ObjectReference?.Dispose();
    }

}
