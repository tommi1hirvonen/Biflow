@using Quartz

@inject ToasterService Toaster
@inject IDbContextFactory<AppDbContext> DbContextFactory
@inject IMediator Mediator
@inject IJSRuntime JS

<HxOffcanvas @ref="offcanvas" Size="OffcanvasSize.Regular" Title="@(schedule.ScheduleId == Guid.Empty ? "New schedule" : "Edit schedule")">
    <BodyTemplate>
        <NavigationLock ConfirmExternalNavigation OnBeforeInternalNavigation="OnBeforeInternalNavigation" />
        <EditForm id="schedule_form" Model="schedule" OnValidSubmit="SubmitSchedule" Context="_context">
            <div class="row">
                <div class="col">
                    <DataAnnotationsValidator />
                    <div>
                        <label class="form-label">Job</label>
                        <HxAutosuggest Enabled="@(schedule.ScheduleId == Guid.Empty && Job is null)"
                        TItem="Job"
                        TValue="Guid"
                        DataProvider="GetJobSuggestionsAsync"
                        ItemFromValueResolver="jobId => Task.FromResult(Jobs.Append(Job).FirstOrDefault(j => j?.JobId == jobId))"
                        ValueSelector="job => job.JobId"
                        TextSelector="job => job.JobName"
                        @bind-Value="schedule.JobId"
                        Context="job"
                        MinimumLength="0"
                        Placeholder="Select job"
                        autocomplete="off">
                            <InputGroupStartTemplate>
                                <div class="input-group-text">
                                    <SvgIcon Icon="LucideIcon.ClipboardList" />
                                </div>
                            </InputGroupStartTemplate>
                            <ItemTemplate>
                                <span class="small">@job.JobName</span>
                            </ItemTemplate>
                        </HxAutosuggest>
                    </div>
                    <div class="mt-3">
                        <label class="form-label">Name</label>
                        <div class="input-group">
                            <div class="input-group-text">
                                <SvgIcon Icon="FeatherIcon.Edit3" />
                            </div>
                            <InputText DisplayName="Name" class="form-control" @bind-Value="schedule.ScheduleName"></InputText>
                        </div>
                    </div>
                    <ValidationMessage For="() => schedule.ScheduleName" />
                    <div class="row mt-3">
                        <div class="col">
                            <label class="form-label">Tags</label>
                            <TagInput TTag="ScheduleTag"
                            Items="allScheduleTags"
                            AllowCustomValues
                            SelectedItems="schedule.Tags"
                            NewItemFromText="text => new ScheduleTag(text) { Color = TagColor.DarkGray }" />
                        </div>
                    </div>
                    <div class="mt-3">
                        <label class="form-label">
                            Cron expression
                            <HxPopover Trigger="PopoverTrigger.Hover" Content="Schedule cron expression cannot be edited once the schedule has been created. To change the expression, a new schedule needs to be created and the old one removed.">
                                <SvgIcon Icon="FeatherIcon.Info" />
                            </HxPopover>
                        </label>
                        <div class="input-group">
                            <div class="input-group-text">
                                <SvgIcon Icon="FeatherIcon.Calendar" />
                            </div>
                            <OnInputText class="form-control" @bind-Value="schedule.CronExpression" />
                        </div>
                    </div>
                    <ValidationMessage For="() => schedule.CronExpression" />
                    @if (CronExpression.IsValidExpression(schedule.CronExpression))
                    {
                        var nextFireTimes = schedule.NextFireTimes().Take(10).ToList();
                        <small class="text-secondary">Description:</small>
                        <br />
                        <small class="text-secondary ms-3">@schedule.GetScheduleDescription()</small>
                        <br />
                        <small class="text-secondary mt-2">Next execution(s) (showing first 10):</small>
                        <div class="row">
                            <div class="col">
                                @foreach (var fireTime in nextFireTimes.Take(5))
                                {
                                    <small class="row text-secondary ms-3">@fireTime</small>
                                }
                            </div>
                            <div class="col">
                                @foreach (var fireTime in nextFireTimes.Skip(5).Take(5))
                                {
                                    <small class="row text-secondary ms-3">@fireTime</small>
                                }
                            </div>
                        </div>
                    }
                    <div class="row mt-3">
                        <label class="form-label">Tag filters</label>
                        <TagInput TTag="StepTag"
                        Items="allStepTags"
                        AllowCustomValues="false"
                        SelectedItems="schedule.TagFilter"
                        NewItemFromText="text => new StepTag(text) { Color = TagColor.DarkGray }" />
                        <div class="form-text">Use tag filters to only include steps with specific tags in scheduled executions.</div>
                    </div>
                    <div class="row mt-3">
                        <div class="col">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="schedule_concurrency_check"
                                checked=@schedule.DisallowConcurrentExecution
                                @bind-value="schedule.DisallowConcurrentExecution">
                                <label class="form-check-label fw-normal" for="schedule_concurrency_check">
                                    Disallow concurrent execution
                                    <HxPopover Trigger="PopoverTrigger.Hover" Content="Allow only one concurrent execution of this job and schedule. This option is useful in cases where the job's duration might overlap with the schedule's next fire time but concurrent execution should not be allowed.">
                                        <SvgIcon Icon="FeatherIcon.Info" />
                                    </HxPopover>
                                </label>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </EditForm>
    </BodyTemplate>
    <FooterTemplate>
        <HxSubmit FormId="schedule_form" Color="ThemeColor.Success">Save</HxSubmit>
        <HxButton CssClass="ms-3" Color="ThemeColor.Secondary" Spinner="false" @onclick="async () => await offcanvas.LetAsync(x => x.HideAsync())">Cancel</HxButton>
    </FooterTemplate>
</HxOffcanvas>

@code {
    // Optional - new schedules will be locked to this job if provided
    [Parameter] public Job? Job { get; set; }

    [Parameter] public IEnumerable<Job> Jobs { get; set; } = [];

    [Parameter] public EventCallback<Schedule> OnSubmit { get; set; }

    private Schedule schedule = new(); // assign placeholder
    private HxOffcanvas? offcanvas;
    private List<StepTag> allStepTags = [];
    private List<ScheduleTag> allScheduleTags = [];

    protected override async Task OnInitializedAsync()
    {
        using var context = DbContextFactory.CreateDbContext();
        allStepTags = await context.StepTags.ToListAsync();
        allStepTags.Sort();
        allScheduleTags = await context.ScheduleTags.ToListAsync();
        allScheduleTags.Sort();
    }

    private async Task SubmitSchedule()
    {
        // New schedule
        if (schedule.ScheduleId == Guid.Empty)
        {
            try
            {
                await Mediator.SendAsync(new CreateScheduleCommand(schedule));
                await OnSubmit.InvokeAsync(schedule);
                await offcanvas.LetAsync(x => x.HideAsync());
            }
            catch (Exception ex)
            {
                Toaster.AddError("Error adding schedule", ex.Message);
            }
        }
        // Existing schedule
        else
        {
            try
            {
                await Mediator.SendAsync(new UpdateScheduleCommand(schedule));
                await OnSubmit.InvokeAsync(schedule);
                await offcanvas.LetAsync(x => x.HideAsync());
            }
            catch (Exception ex)
            {
                Toaster.AddError("Error editing schedule", ex.Message);
            }
        }
    }

    public async Task ShowAsync(Guid scheduleId)
    {
        if (scheduleId != Guid.Empty)
        {
            using var context = DbContextFactory.CreateDbContext();
            schedule = await context.Schedules
                .AsNoTracking()
                .Include(s => s.TagFilter)
                .Include(s => s.Tags)
                .FirstAsync(s => s.ScheduleId == scheduleId);
        }
        else if (scheduleId == Guid.Empty)
        {
            var jobId = Job?.JobId ?? Guid.Empty;
            ArgumentNullException.ThrowIfNull(jobId);
            schedule = new()
            {
                JobId = (Guid)jobId
            };
        }

        await offcanvas.LetAsync(x => x.ShowAsync());
    }

    private Task<AutosuggestDataProviderResult<Job>> GetJobSuggestionsAsync(AutosuggestDataProviderRequest request)
    {
        return Task.FromResult(new AutosuggestDataProviderResult<Job>
        {
            Data = Jobs
                .Where(j => j.JobName.ContainsIgnoreCase(request.UserInput))
                .OrderBy(j => j.JobName)
        });
    }

    private async Task OnBeforeInternalNavigation(LocationChangingContext context)
    {
        var confirmed = await JS.InvokeAsync<bool>("confirm", "Discard unsaved changes?");
        if (!confirmed)
        {
            context.PreventNavigation();
        }
    }
}
