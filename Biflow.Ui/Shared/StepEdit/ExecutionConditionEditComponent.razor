@inject MarkupHelperService MarkupHelper
@inject IHxMessengerService Messenger

@using CodingSeb.ExpressionEvaluator

@if (Step is not null)
{
    <div class="row mt-1">
        <label class="form-label">
            Execution condition expression
            &nbsp;
            <span style="cursor: pointer;" @onclick="async () => await HelpOffcanvas.LetAsync(x => x.ShowAsync())">
                @MarkupHelper.FromFile("icons/feather/help-circle.svg")
            </span>
        </label>
        <div class="input-group input-group-sm">
            <div class="input-group-text">
                @MarkupHelper.FromFile("icons/feather/check-square.svg")
            </div>
            <InputTextArea class="form-control form-control-sm" @bind-Value="Step.ExecutionConditionExpression" style="font-family: monospace;" rows="3"></InputTextArea>
        </div>
        <div class="form-text">The return type of the expression should always be boolean (True/False).</div>
    </div>
    <div class="row mt-3">
        <div class="col">
            <HxButton OnClick="TestEvaluate" Color="ThemeColor.Light" Size="ButtonSize.Small">
                @MarkupHelper.FromFile("icons/feather/check.svg")
                Test evaluate / validate
            </HxButton>
        </div>
    </div>
    <h5 class="mt-3">Parameters</h5>
    <table class="table table-sm">
        <thead>
            <tr>
                <th>Name</th>
                <th>Inherit from job</th>
                <th></th>
                <th></th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @if (!Step.ExecutionConditionParameters.Any())
            {
                <tr><td colspan="5">No parameters</td></tr>
            }
            @{
                var count = 0;
            }
            @foreach (var param in Step.ExecutionConditionParameters)
            {
                <tr>
                    <td>
                        <HxInputText InputSize="InputSize.Small" @bind-Value="param.ParameterName" placeholder="Name"></HxInputText>
                    </td>
                    <td class="align-middle">
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" id="condition_inherit_param_@count"
                                    checked=@(param.JobParameterId is not null)
                                    disabled=@((!JobParameters?.Any() ?? true))
                                    @onchange="args => SetJobParameter((bool)args.Value!, param)">
                            <label class="form-check-label" for="condition_inherit_param_@count"></label>
                        </div>
                    </td>
                    @if (param.JobParameterId is not null)
                    {
                        <td colspan="2">
                            <InputSelect class="form-select form-select-sm" @bind-Value="param.JobParameterId">
                                @foreach (var jobParam in JobParameters?.OrderBy(p => p.ParameterName) ?? Enumerable.Empty<JobParameter>())
                                            {
                                    <option value="@jobParam.ParameterId">
                                        @jobParam.ParameterName (@jobParam.ParameterValueType = @jobParam.ParameterValue)
                                    </option>
                                            }
                            </InputSelect>
                        </td>
                    }
                    else
                    {
                        <ParameterTypeValueEditComponent Parameter="param" />
                    }
                    <td>
                        <HxButtonGroup Size="ButtonGroupSize.Small" CssClass="btn-row">
                            <HxButton Color="ThemeColor.Light" Size="ButtonSize.Small" CssClass="btn-row" @onclick="() => Step.ExecutionConditionParameters.Remove(param)">
                                @MarkupHelper.FromFile("icons/feather/delete.svg")
                            </HxButton>
                        </HxButtonGroup>
                    </td>
                </tr>
                count++;
            }
        </tbody>
    </table>
    var type = ParameterValueType.String;
    <HxButton Color="ThemeColor.Light" Size="ButtonSize.Small" @onclick="() => Step.ExecutionConditionParameters.Add(new ExecutionConditionParameter { ParameterValueType = type, ParameterValue = string.Empty })">
        @MarkupHelper.FromFile("icons/feather/plus.svg")
    </HxButton>
}

<HxOffcanvas @ref="HelpOffcanvas" Size="OffcanvasSize.Large" Backdrop="OffcanvasBackdrop.False" Title="Execution conditions">
    <BodyTemplate>
        <p>Use C# expressions to control whether the step is executed or not when the step's execution phase is reached (in execution phase mode) or all its dependencies have completed (in dependency mode).</p>
        <p>The return type for the final expression must always be boolean (True/False), however you can test and develop expressions using any kind of return type.</p>
        <p>Use parameters to dynamically pass values to the evaluated expression.</p>
        
        <h6>Simple expression</h6>
        <p>The following expression takes two integer variables <code>count1</code>, <code>count2</code> and a boolean variable <code>bool1</code> which are passed using parameters of the same name.</p>
        <pre><code>
            count1 == 0 && count2 > 0 || bool1
        </code></pre>
        
        <h6>Working with datetimes</h6>
        <p>The following expression takes one parameter <code>lastLoadDateTime</code> of type DateTime.</p>
        <pre><code>
            DateTime.Today.AddDays(-5) > lastLoadDateTime
        </code></pre>

        <h6>Working with strings</h6>
        <p>The following expressions take one parameter <code>myText</code> of type String.</p>
        <pre><code>
            myText.ToLower().Contains("test if mytext contains this text")
        </code></pre>

        <h6>Working with arrays</h6>
        <pre><code>
            new string[] { "list", "of", "allowed", "values" }.Contains(myText)
            // myText = "allow" => false

            new string[] { "list", "of", "allowed", "values" }.Any(v => v.Contains(myText))
            // myText = "allow" => true

            myText.Split(',').Length > 3
            // myText = "comma,separated,list,of,values" => true
        </code></pre>
        
        <br/>

        <p>The following namespaces, their classes and methods are available for use in expressions:</p>
        <ul>
            <li>System</li>
            <li>System.Linq</li>
            <li>System.Text</li>
            <li>System.Text.RegularExpressions</li>
            <li>System.ComponentModel</li>
            <li>System.Dynamic</li>
            <li>System.Collections</li>
            <li>System.Collections.Generic</li>
            <li>System.Collections.Specialized</li>
            <li>System.Globalization</li>
        </ul>
        <p>The following operators are supported:</p>
        <table class="table table-sm">
            <thead>
                <tr>
                    <th>Operator</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>x.y</td><td>Member access</td></tr>
                <tr><td>x?.y</td><td>Null-conditional Member access</td></tr>
                <tr><td>x?[y]</td><td>Null-conditional index</td></tr>
                <tr><td>f(x)</td><td>Invocation</td></tr>
                <tr><td>a[x]</td><td>Index</td></tr>
                <tr><td>x++</td><td>Postfix increment</td></tr>
                <tr><td>x--</td><td>Postfix decrement</td></tr>
                <tr><td>new</td><td>Instanciate</td></tr>
                <tr><td>typeof</td><td>Get the System.Type instance for a type</td></tr>
                <tr><td>default(T)</td><td>Default value of a type</td></tr>
                <tr><td>sizeof</td><td>Number of bytes used by a variable or a type</td></tr>
                <tr><td>+x</td><td>Positive value</td></tr>
                <tr><td>-x</td><td>Negative value</td></tr>
                <tr><td>!x</td><td>Logical Negation</td></tr>
                <tr><td>~x</td><td>Bitwise complement</td></tr>
                <tr><td>++x</td><td>Prefix increment</td></tr>
                <tr><td>--x</td><td>Prefix decrement</td></tr>
                <tr><td>(T)x</td><td>Explicit cast</td></tr>
                <tr><td>x * y</td><td>Multiplication</td></tr>
                <tr><td>x / y</td><td>Division</td></tr>
                <tr><td>x % y</td><td>Modulus (Integer remainder)</td></tr>
                <tr><td>x + y</td><td>Addition</td></tr>
                <tr><td>x - y</td><td>Substraction</td></tr>
                <tr><td>x &#60;&#60; y</td><td>Left shift (bits)</td></tr>
                <tr><td>x >> y</td><td>Right shift (bits)</td></tr>
                <tr><td>x &#60; y</td><td>Less than</td></tr>
                <tr><td>x > y</td><td>Greater than</td></tr>
                <tr><td>x &#60;= y</td><td>Less than or equal</td></tr>
                <tr><td>x >= y</td><td>Greater than or equal</td></tr>
                <tr><td>is</td><td>Type testing</td></tr>
                <tr><td>x == y</td><td>Equality comparison</td></tr>
                <tr><td>x != y</td><td>Not equal</td></tr>
                <tr><td>x & y</td><td>Logical and (bits)</td></tr>
                <tr><td>x ^ y</td><td>Logical XOR (bits)</td></tr>
                <tr><td>x | y</td><td>Logical OR (bits)</td></tr>
                <tr><td>x && y</td><td>Conditional and (booleans)</td></tr>
                <tr><td>x || y</td><td>Conditional or (booleans)</td></tr>
                <tr><td>x ?? y</td><td>Null coalescing (if null take that)</td></tr>
                <tr><td>t ? x : y</td><td>Ternary conditional operator</td></tr>
                <tr><td>=></td><td>Lambda (Expressions and bodied)</td></tr>
            </tbody>
        </table>
    </BodyTemplate>
    <FooterTemplate>
        <HxButton Color="ThemeColor.Secondary" OnClick="async () => await HelpOffcanvas.LetAsync(x => x.HideAsync())">
            Close
        </HxButton>
    </FooterTemplate>
</HxOffcanvas>

@code {
    [Parameter]
    public Step? Step { get; set; }

    [Parameter]
    public ICollection<JobParameter>? JobParameters { get; set; }

    private HxOffcanvas? HelpOffcanvas { get; set; }

    private void SetJobParameter(bool inheritFromJob, ExecutionConditionParameter param)
    {
        if (inheritFromJob)
        {
            param.JobParameterId = JobParameters?.FirstOrDefault()?.ParameterId;
        }
        else
        {
            param.JobParameterId = null;
        }
    }

    private void TestEvaluate()
    {
        if (string.IsNullOrWhiteSpace(Step?.ExecutionConditionExpression))
        {
            Messenger.AddWarning("Execution condition expression is empty");
            return;
        }
        try
        {
            ArgumentNullException.ThrowIfNull(JobParameters);
            var evaluator = new ExpressionEvaluator
            {
                OptionScriptEvaluateFunctionActive = false,
                OptionCanDeclareMultiExpressionsLambdaInSimpleExpressionEvaluate = false
            };
            evaluator.Namespaces.Remove("System.IO");
            foreach (var param in Step.ExecutionConditionParameters)
            {
                param.SetParameterValue();
                var value = param.JobParameterId is not null
                ? JobParameters.First(p => p.ParameterId == param.JobParameterId).ParameterValue
                : param.ParameterValue;
                evaluator.Variables[param.ParameterName] = value;
            }
            var result = evaluator.Evaluate(Step.ExecutionConditionExpression);

            if (result is bool b)
            {
                Messenger.AddInformation($"Result: {b}");
            }
            else
            {
                Messenger.AddWarning("Return type is not boolean", $"Result: {result}");
            }
        }
        catch (Exception ex)
        {
            Messenger.AddError(ex.Message);
        }
    }
}
