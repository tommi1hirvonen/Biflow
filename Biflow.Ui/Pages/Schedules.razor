@page "/schedules/{Component?}"

@implements IDisposable

@inject IDbContextFactory<AppDbContext> DbFactory
@inject ToasterService Toaster
@inject ISchedulerService SchedulerService

<style>
    tr a {
        text-decoration: none;
    }

        tr a:hover {
            text-decoration: underline;
        }

    .white-space-pre {
        white-space: pre;
    }
</style>

<PageTitle>Schedules | Biflow</PageTitle>

<h4>Schedules</h4>

<div class="row mt-3 mb-4">
    <div class="col">
        <ul class="nav nav-tabs" role="tablist">
            <li class="nav-item" role="presentation">
                <NavLink class="nav-link" Match="NavLinkMatch.All" href="@($"schedules")">
                    <CxIcon Icon="FeatherIcon.List" />
                    List
                </NavLink>
            </li>
            <li class="nav-item" role="presentation">
                <NavLink class="nav-link" Match="NavLinkMatch.All" href="@($"schedules/graph")">
                    <CxIcon Icon="LucideIcon.BarChartHorizontal" />
                    Graph
                </NavLink>
            </li>
        </ul>
    </div>
</div>

@{
    var filterJobs = jobs?
        .Where(j => schedules?.Any(s => s.JobId == j.JobId) ?? false)
        .Select(j => (j.JobId, j.JobName))
        .Concat(UserState.Schedules.JobFilter)
        .Distinct()
        .OrderBy(j => j.JobName)
        .AsEnumerable()
        ?? [];
}

<div class="row">
    <div class="col-auto">
        <FilterDropdown TItem="(Guid JobId, string JobName)"
                        FilterSet="UserState.Schedules.JobFilter"
                        Items="filterJobs"
                        IdSelector="j => j.JobId.ToString()"
                        TextSelector="j => j.JobName"
                        IsSearchable
                        DelayItemsRender
                        OnChange="StateHasChanged">
            <TitleTemplate>
                <CxIcon Icon="FeatherIcon.Filter" />
                Job
            </TitleTemplate>
        </FilterDropdown>
    </div>
    <div class="col">
        <div class="input-group input-group-sm">
            <div class="input-group-text">
                <CxIcon Icon="FeatherIcon.Search" />
            </div>
            <input type="search"
                   class="form-control form-control-sm"
                   placeholder="Search schedules"
                   style="max-width: 20rem;"
                   @bind-value="UserState.Schedules.ScheduleFilter"
                   @bind-value:event="oninput" />
        </div>
    </div>
</div>

@if (Component is null)
{
    <SchedulesList Schedules="schedules" Jobs="jobs" FilteredSchedules="FilteredSchedules" OnSchedulesChanged="StateHasChanged" />
}
else if (Component == "graph")
{
    <SchedulesGraph Schedules="schedules" FilteredSchedules="FilteredSchedules" OnSchedulesChanged="StateHasChanged" />
}
else
{
    <p>No component to display with component parameter @Component</p>
}

@code {
    [CascadingParameter] public UserState UserState { get; set; } = null!;

    [Parameter] public string? Component { get; set; }

    private readonly CancellationTokenSource cts = new();

    private List<Job>? jobs;
    private List<Schedule>? schedules;

    private IEnumerable<Schedule>? FilteredSchedules =>
        schedules
        ?.Where(s => !UserState.Schedules.JobFilter.Any() || UserState.Schedules.JobFilter.Any(f => f.JobId == s.JobId))
        .Where(s => string.IsNullOrEmpty(UserState.Schedules.ScheduleFilter) || s.ScheduleName.ContainsIgnoreCase(UserState.Schedules.ScheduleFilter));

    protected override async Task OnInitializedAsync()
    {
        using var context = await Task.Run(DbFactory.CreateDbContext);
        jobs = await context.Jobs
            .OrderBy(job => job.JobName)
            .ToListAsync(cts.Token);
        schedules = await context.Schedules
            .AsNoTrackingWithIdentityResolution()
            .Include(schedule => schedule.Job)
            .Include(schedule => schedule.Tags)
            .OrderBy(schedule => schedule.Job.JobName)
            .ThenBy(schedule => schedule.ScheduleName)
            .ToListAsync(cts.Token);
    }

    public void Dispose()
    {
        cts.Cancel();
        cts.Dispose();
    }
}
