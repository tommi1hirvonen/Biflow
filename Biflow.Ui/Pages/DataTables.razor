@page "/datatables/{Page?}/{TableId:guid?}"

@inject IDbContextFactory<AppDbContext> DbContextFactory
@inject AuthenticationStateProvider AuthenticationStateProvider

<PageTitle>Data Tables | Biflow</PageTitle>



@if (Page is null)
{
    <DataTablesList Tables="tables" Categories="categories" Connections="connections" />
}
else if (Page == "edit")
{
    <DataTableEditor Table="table" />
}
else if (Page == "import")
{
    <DataTableImport TableId="TableId" />
}
else
{
    <p>Sorry, nothing at this address.</p>
}

@code {
    [Parameter] public string? Page { get; set; }

    [Parameter] public Guid? TableId { get; set; }

    private MasterDataTable? table;
    private List<MasterDataTable>? tables;
    private List<MsSqlConnection>? connections;
    private List<MasterDataTableCategory>? categories;

    protected override async Task OnInitializedAsync()
    {
        using var context = await Task.Run(DbContextFactory.CreateDbContext);
        tables = await context.MasterDataTables
            .AsNoTrackingWithIdentityResolution()
            .Include(t => t.Category)
            .Include(t => t.Connection)
            .ThenInclude(c => c.Credential)
            .Include(t => t.Lookups)
            .OrderBy(t => t.DataTableName)
            .ToListAsync();

        var lookupTableIds = tables
            .SelectMany(t => t.Lookups)
            .Select(l => l.LookupTableId)
            .Distinct()
            .ToList();

        // Instead of including lookup tables in the main query, fetch them here with IgnoreQueryFilters().
        // This way we can ensure that all lookups are included even if the user has no authorization on all data tables.
        var lookupTables = await context.MasterDataTables
            .AsNoTrackingWithIdentityResolution()
            .IgnoreQueryFilters()
            .Include(t => t.Connection)
            .ThenInclude(c => c.Credential)
            .Where(t => lookupTableIds.Contains(t.DataTableId))
            .ToListAsync();

        // Map lookup tables to the main tables list.
        foreach (var table in tables)
        {
            foreach (var lookup in table.Lookups)
            {
                var lt = lookupTables.FirstOrDefault(t => t.DataTableId == lookup.LookupTableId);
                if (lt is not null)
                {
                    lookup.LookupTable = lt;
                }
            }
        }

        // For admins and editors, show all available table categories.
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        if (authState.User.IsInRole(Roles.Admin) || authState.User.IsInRole(Roles.Editor))
        {
            categories = await context.MasterDataTableCategories
                .AsNoTrackingWithIdentityResolution()
                .OrderBy(c => c.CategoryName)
                .ToListAsync();
        }
        // For other users, only show categories for jobs they are authorized to see.
        else
        {
            categories = tables
                .Select(j => j.Category)
                .Where(c => c is not null)
                .Cast<MasterDataTableCategory>()
                .DistinctBy(c => c.CategoryId)
                .ToList();
        }
        connections = await context.SqlConnections
            .AsNoTrackingWithIdentityResolution()
            .Include(c => c.Credential)
            .OrderBy(c => c.ConnectionName)
            .ToListAsync();
    }

    protected override void OnParametersSet()
    {
        table = tables?.FirstOrDefault(t => t.DataTableId == TableId);
    }
}
