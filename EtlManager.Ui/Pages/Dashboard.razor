@page "/dashboard"

@inject IDbContextFactory<EtlManagerContext> DbFactory
@inject MarkupHelperService MarkupHelper
@inject IJSRuntime JS

<PageTitle>Dashboard | ETL Manager</PageTitle>

<h4>Dashboard</h4>

<div class="btn-toolbar mt-3">
    <HxButton Size="ButtonSize.Small" Color="ThemeColor.Primary" OnClick="LoadData" Enabled="!Loading">
        @MarkupHelper.FromFile("icons/feather/refresh-cw.svg")
        Load report
    </HxButton>
</div>

<div class="row mt-3">
    <div class="col-auto d-inline-flex align-items-center">
        <label>From:</label>
        <input @bind-value="FromDate" class="form-control form-control-sm ms-2" type="date">
        <label class="ms-4">To:</label>
        <input @bind-value="ToDate" class="form-control form-control-sm ms-2" type="date">
    </div> 
</div>

<div class="row mt-3">
    <div class="col-auto">
        <div class="form-check form-check-inline">
            <input type="checkbox" class="form-check-input" id="only_schedule"
                   @bind-value="OnlyScheduled"
                   checked=@OnlyScheduled>
            <label class="form-check-label" for="only_schedule">Only scheduled executions</label>
        </div>
        <div class="form-check form-check-inline ms-3">
            <input type="checkbox" class="form-check-input" id="include_deleted"
                   @bind-value="IncludeDeleted"
                   checked=@IncludeDeleted>
            <label class="form-check-label" for="include_deleted">Include deleted jobs/steps</label>
        </div>
    </div>
</div>

<div class="row mt-4">
    <div class="col-xl">
        <div class="card shadow-sm">
            <h6 class="card-header">
                @MarkupHelper.FromFile("icons/feather/clock.svg")
                &nbsp;
                Average execution duration
            </h6>
            <div class="card-body">
                @if (!ReportLoaded)
                {
                    <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
                }
                <canvas class="w-100" id="myChart1" width="900" height="400"></canvas>
            </div>
        </div>
    </div>
    <div class="col-xl mt-4 mt-xl-0">
        <div class="card shadow-sm">
            <h6 class="card-header">
                @MarkupHelper.FromFile("icons/feather/percent.svg")
                &nbsp;
                Job success rate
            </h6>
            <div class="card-body">
                @if (!ReportLoaded)
                {
                    <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
                }
                <canvas class="w-100" id="myChart2" width="900" height="400"></canvas>
            </div>
        </div>
    </div>
</div>
<div class="row my-4">
    <div class="col-xl">
        <div class="card shadow-sm">
            <h6 class="card-header">
                @MarkupHelper.FromFile("icons/feather/activity.svg")
                &nbsp;
                Number of executions
            </h6>
            <div class="card-body">
                @if (!ReportLoaded)
                {
                    <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
                }
                <canvas class="w-100" id="myChart3" width="900" height="400"></canvas>
            </div>
        </div>
    </div>
    <div class="col-xl mt-4 mt-xl-0 d-flex align-items-stretch">
        <div class="card shadow-sm flex-fill">
            <h6 class="card-header">
                @MarkupHelper.FromFile("icons/feather/alert-octagon.svg")
                &nbsp;
                Top 5 failing steps
            </h6>
            <div class="card-body @(ReportLoaded ? "px-0" : null)">
                @if (!ReportLoaded)
                {
                    <p class="@ReportNotLoadedClass">@ReportNotLoadedMessage</p>
                }
                else
                {
                    <table class="table table-striped table-sm">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Step</th>
                                <th>Job</th>
                                <th>Success %</th>
                                <th># of executions</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (TopFailedSteps is not null)
                            {
                                @for (int i = 0; i < TopFailedSteps.Count; i++)
                                {
                                    <tr>
                                        <td>@(i + 1)</td>
                                        <td>
                                            @TopFailedSteps[i].StepName
                                        </td>
                                        <td>
                                            @TopFailedSteps[i].JobName
                                        </td>
                                        <td>@TopFailedSteps[i].SuccessPercent.FormatPercentage(2)</td>
                                        <td>@TopFailedSteps[i].NoOfExecutions</td>
                                    </tr>
                                }
                            }
                        </tbody>
                    </table>
                }
            </div>
        </div>
    </div>
</div>

@code {

    private Dictionary<string, List<TimeSeriesItem>> TimeSeriesItems { get; set; } = new Dictionary<string, List<TimeSeriesItem>>();

    private Dictionary<string, string> JobColors = new Dictionary<string, string>();
    private List<ReportingJob>? Jobs { get; set; }

    private List<TopStep>? TopFailedSteps { get; set; }

    private DateTime FromDate { get; set; } = DateTime.Now.Date.AddDays(-90);
    private DateTime ToDate { get; set; } = DateTime.Now.Date.AddDays(1);

    private bool IncludeDeleted { get; set; } = false;

    private bool OnlyScheduled { get; set; } = true;

    private bool Loading { get; set; }

    private bool ReportLoaded { get; set; } = false;

    private const string ReportNotLoadedMessage = "Load report to show data.";
    private const string ReportNotLoadedClass = "text-secondary small fst-italic";

    private async Task LoadData()
    {
        Loading = true;

        using var context = await Task.Run<EtlManagerContext>(DbFactory.CreateDbContext);

        // Get duration executions
        var executionsQuery = context.Executions
            .AsNoTrackingWithIdentityResolution()
            .Where(e => e.EndDateTime != null && e.CreatedDateTime >= FromDate && e.CreatedDateTime < ToDate);

        if (!IncludeDeleted)
        {
            executionsQuery = executionsQuery.Where(e => context.Jobs.Where(job => job.JobId == e.JobId).Any());
        }

        if (OnlyScheduled)
        {
            executionsQuery = executionsQuery.Where(e => e.ScheduleId != null);
        }

        // Group job executions by job names to day level and calculate each job's average duration as well as the number of executions.
        var executions = await executionsQuery
            .OrderBy(e => e.CreatedDateTime).ToListAsync();
        var executions_ = executions.GroupBy(group => new
        {
            group.JobName,
            ((DateTimeOffset)group.CreatedDateTime.LocalDateTime).Date
        })
            .Select(select => new TimeSeriesItem
            {
                DurationInMinutes = select.Average(total => (decimal)(total.ExecutionInSeconds ?? 0) / 60),
                JobName = select.Key.JobName,
                Date = select.Key.Date,
                NumberOfExecutions = select.Count()
            });

        TimeSeriesItems = executions_
            .GroupBy(e => e.JobName)
            .ToDictionary(e => e.Key, e => e.ToList());


        // Job success rates
        var jobsQuery = context.Executions
            .AsNoTrackingWithIdentityResolution()
            .Include(e => e.StepExecutions)
            .ThenInclude(e => e.StepExecutionAttempts)
            .Where(e => e.CreatedDateTime >= FromDate && e.CreatedDateTime < ToDate);

        if (!IncludeDeleted)
        {
            jobsQuery = jobsQuery.Where(e => context.Jobs.Where(job => job.JobId == e.JobId).Any());
        }

        if (OnlyScheduled)
        {
            jobsQuery = jobsQuery.Where(e => e.ScheduleId != null);
        }

        // Group job executions by job name and calculate average success percentage.
        var jobs = await jobsQuery.ToListAsync();
        Jobs = jobs.GroupBy(group => group.JobName)
        .Select(select => new ReportingJob
        {
            SuccessPercent = select.Average(total => total.GetSuccessPercent()),
            JobName = select.Key
        })
        .OrderByDescending(order => order.SuccessPercent)
        .ToList();

        // Get a temporary list of all job names to retrieve their colors.
        var jobNames = Jobs.Select(job => job.JobName).Concat(TimeSeriesItems.Select(tsi => tsi.Key)).Distinct().OrderBy(name => name).ToList();
        JobColors = jobNames
            .Select((name, index) => new { Item = name, Index = index })
            .ToDictionary(elem => elem.Item, elem => colors[elem.Index % colors.Count]);


        // Get top failed steps
        var topFailedStepsQuery = context.StepExecutions
            .AsNoTrackingWithIdentityResolution()
            .Include(e => e.StepExecutionAttempts)
            .Include(e => e.Execution)
            .Where(e => e.Execution.CreatedDateTime >= FromDate && e.Execution.CreatedDateTime < ToDate);

        if (!IncludeDeleted)
        {
            topFailedStepsQuery = topFailedStepsQuery.Where(e => context.Steps.Where(step => step.StepId == e.StepId).Any());
        }

        if (OnlyScheduled)
        {
            topFailedStepsQuery = topFailedStepsQuery.Where(e => e.Execution.ScheduleId != null);
        }

        var topFailedStepsGrouping = await topFailedStepsQuery.ToListAsync();

        // Group step executions by step and job and calculate success percentages
        // based on the number of completed executions and the number of all executions.
        TopFailedSteps = topFailedStepsGrouping
            .GroupBy(group => new { group.StepId, group.StepName, group.Execution.JobId, group.Execution.JobName })
            .Select(select => new TopStep
            {
                StepName = select.Key.StepName,
                StepId = select.Key.StepId,
                JobName = select.Key.JobName,
                JobId = select.Key.JobId ?? Guid.Empty,
                NoOfExecutions = select.Count(),
                SuccessPercent = (decimal)select.Count(e => e.StepExecutionAttempts.Any(attempt => attempt.ExecutionStatus == StepExecutionStatus.Succeeded)) / select.Count() * 100
            })
            .OrderBy(order => order.SuccessPercent)
            .Where(e => e.SuccessPercent < 100)
            .Take(5)
            .ToList();

        // Create JSON dataset objects that are passed to the JS code in site.js via JSInterop.
        var durationDataset = TimeSeriesItems.Select((e, index) =>
        new
        {
            label = e.Key,
            fill = false,
            backgroundColor = JobColors[e.Key],
            borderColor = JobColors[e.Key],
            data = e.Value.Select(v => new { x = v.Date.ToString("o"), y = v.DurationInMinutes }),
            tension = 0.3
        });
        var durationDatasetJson = JsonSerializer.Serialize(durationDataset);

        var noOfExecutionsDataset = TimeSeriesItems.Select((e, index) =>
        new
        {
            label = e.Key,
            fill = false,
            backgroundColor = JobColors[e.Key],
            borderColor = JobColors[e.Key],
            data = e.Value.Select(v => new { x = v.Date.ToString("o"), y = v.NumberOfExecutions }),
            tension = 0.3
        });
        var noOfExecutionsJson = JsonSerializer.Serialize(noOfExecutionsDataset);

        var successRateDataset = Jobs.Select(job =>
        new
        {
            label = job.JobName,
            data = decimal.Round(job.SuccessPercent, 2),
            color = JobColors[job.JobName]
        });
        var successRateDatasetJson = JsonSerializer.Serialize(successRateDataset);

        ReportLoaded = true;

        await JS.InvokeVoidAsync("drawDurationGraph", durationDatasetJson);
        await JS.InvokeVoidAsync("drawNoOfExecutionsGraph", noOfExecutionsJson);
        await JS.InvokeVoidAsync("drawSuccessRateGraph", successRateDatasetJson);

        Loading = false;
    }

    private List<string> colors = new List<string>
        {
            "#727cf5", // indigo
            "#0acf97", // teal
            "#007bff", // blue
            "#fa5c7c", // red
            "#ffc107", // yellow
            "#28a745", // green
            "#fd7e14", // orange
            "#17a2b8", // cyan
            "#e83e8c", // pink
            "#6f42c1" // purple
        };

    public class TimeSeriesItem
    {
        public string JobName { get; set; } = string.Empty;
        public DateTime Date { get; set; }
        public decimal DurationInMinutes { get; set; }
        public int NumberOfExecutions { get; set; }
    }

    public class ReportingJob
    {
        public decimal SuccessPercent { get; set; }
        public string JobName { get; set; } = string.Empty;
    }

    public class TopStep
    {
        public decimal SuccessPercent { get; set; }
        public string StepName { get; set; } = string.Empty;
        public Guid StepId { get; set; }
        public string JobName { get; set; } = string.Empty;
        public Guid JobId { get; set; }
        public int NoOfExecutions { get; set; }
    }

}
