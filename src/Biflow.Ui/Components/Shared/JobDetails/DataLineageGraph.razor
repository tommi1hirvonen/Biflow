
@*CSS definitions for the dependency graph nodes and paths created in site.js through JSInterop.*@
<style>
    html, body {
        height: 100%;
    }
</style>

<PageTitle>@Job?.JobName | Data objects | Biflow</PageTitle>

<div class="row align-items-end mb-3">
    <div class="col-xl-7 col-lg-9 col-12">
        <HxAutosuggest @bind-Value="_filterNodeId"
                       @bind-Value:after="LoadGraphAsync"
                       TItem="INode"
                       TValue="string"
                       ItemFromValueResolver="v => Task.FromResult(_graphNodes.GetValueOrDefault(v)!)"
                       ValueSelector="item => item.Id"
                       TextSelector="x => x.Name"
                       DataProvider="ProvideSuggestionsAsync"
                       MinimumLength="0"
                       Delay="1"
                       InputSize="InputSize.Small"
                       Placeholder="Filter node"
                       autocomplete="off">
            <ItemTemplate Context="item">
                @if (item is StepNode step)
                {
                    <span class="small">
                        <DisplayStepTypeIcon StepType="step.Step.DisplayStepType" />
                        @step.Name
                    </span>
                }
                else if (item is DataNode data)
                {
                    <span class="small font-monospace">@data.Name</span>
                }
            </ItemTemplate>
            <EmptyTemplate>
                <span class="p-2">No matching nodes</span>
            </EmptyTemplate>
        </HxAutosuggest>
    </div>
    <div class="col-lg-auto d-flex flex-row align-items-end">
        <div class="form-group">
            <label class="form-label">Depth backwards</label>
            <HxPopover Trigger="PopoverTrigger.Hover" Html Content="@("<p>The depth of traversal backwards when drawing the lineage graph starting from the filtered node.</p><p>Available only when the graph has been filtered.</p><p>0 = no limit</p>")">
                <ChildContent>
                    <span class="cursor-pointer">
                        <SvgIcon Icon="LucideIcon.Info" />
                    </span>
                </ChildContent>
            </HxPopover>
            <input class="form-control form-control-sm" type="number" @bind-value="FilterDepthBackwards" disabled=@(_filterNodeId is null) style="max-width: 9rem;" />
        </div>
        <div class="form-group ms-3">
            <label class="form-label">Depth forwards</label>
            <HxPopover Trigger="PopoverTrigger.Hover" Html Content="@("<p>The depth of traversal forwards when drawing the lineage graph starting from the filtered node.</p><p>Available only when the graph has been filtered.</p><p>0 = no limit</p>")">
                <ChildContent>
                    <span class="cursor-pointer">
                        <SvgIcon Icon="LucideIcon.Info" />
                    </span>
                </ChildContent>
            </HxPopover>
            <input class="form-control form-control-sm" type="number" @bind-value="FilterDepthForwards" disabled=@(_filterNodeId is null) style="max-width: 9rem;" />
        </div>
        <HxButtonGroup Size="ButtonGroupSize.Small" CssClass="ms-3">
            <HxButton CssClass="btn-auto" Size="ButtonSize.Small" Color="ThemeColor.None" OnClick="LoadGraphAsync">
                Apply depth filters
            </HxButton>
            <HxDropdownButtonGroup AutoClose="DropdownAutoClose.Outside">
                <HxDropdownToggleButton Size="ButtonSize.Small" Color="ThemeColor.None" CssClass="btn-auto">
                    Direction
                </HxDropdownToggleButton>
                <HxDropdownContent CssClass="p-3">
                    <div class="row mt-2" style="min-width: 12rem;">
                        <div class="col">
                            <div class="form-check">
                                <input class="form-check-input" type="radio" id="direction_radio_admin"
                                       checked=@(_direction == DependencyGraphDirection.LeftToRight)
                                       @onchange="@(_ => SetDirectionAsync(DependencyGraphDirection.LeftToRight))">
                                <label class="form-check-label fw-normal" for="direction_radio_admin">
                                    <SvgIcon Icon="LucideIcon.MoveRight" />
                                    Left to right
                                </label>
                            </div>
                            <div class="form-check mt-1">
                                <input class="form-check-input" type="radio" id="direction_radio_editor"
                                       checked=@(_direction == DependencyGraphDirection.RightToLeft)
                                       @onchange="@(_ => SetDirectionAsync(DependencyGraphDirection.RightToLeft))">
                                <label class="form-check-label fw-normal" for="direction_radio_editor">
                                    <SvgIcon Icon="LucideIcon.MoveLeft" />
                                    Right to left
                                </label>
                            </div>
                            <div class="form-check mt-1">
                                <input class="form-check-input" type="radio" id="direction_radio_operator"
                                       checked=@(_direction == DependencyGraphDirection.TopToBottom)
                                       @onchange="@(_ => SetDirectionAsync(DependencyGraphDirection.TopToBottom))">
                                <label class="form-check-label fw-normal" for="direction_radio_operator">
                                    <SvgIcon Icon="LucideIcon.MoveDown" />
                                    Top to bottom
                                </label>
                            </div>
                            <div class="form-check mt-1">
                                <input class="form-check-input" type="radio" id="direction_radio_viewer"
                                       checked=@(_direction == DependencyGraphDirection.BottomToTop)
                                       @onchange="@(_ => SetDirectionAsync(DependencyGraphDirection.BottomToTop))">
                                <label class="form-check-label fw-normal" for="direction_radio_viewer">
                                    <SvgIcon Icon="LucideIcon.MoveUp" />
                                    Bottom to top
                                </label>
                            </div>
                        </div>
                    </div>
                </HxDropdownContent>
            </HxDropdownButtonGroup>
        </HxButtonGroup>        
    </div>
</div>

@if (Job is not null)
{
    <DependencyGraph @ref="_dependencyGraph"
                     TItem="INode"
                     AfterRender="LoadGraphAsync"
                     ItemFromNodeIdSelector="nodeId => _graphNodes.GetValueOrDefault(nodeId)"
                     CssClass="dependency-graph">
        <ContextMenuTemplate Context="node">
            <li>
                <span class="dropdown-item" role="button" @onclick="async () => { _filterNodeId = node.Id; await LoadGraphAsync();}">
                    <SvgIcon Icon="LucideIcon.Filter" />
                    Limit graph to this
                </span>
            </li>
        </ContextMenuTemplate>
    </DependencyGraph>
}

@code {
    [CascadingParameter] public Job? Job { get; set; }

    [CascadingParameter] public List<Step>? Steps { get; set; }
    
    [Parameter] public Guid? InitialStepId { get; set; }

    private string? _filterNodeId;
    private DependencyGraph<INode>? _dependencyGraph;
    private Dictionary<string, INode> _graphNodes = [];
    private DependencyGraphDirection _direction = DependencyGraphDirection.LeftToRight;

    private int FilterDepthBackwards
    {
        get;
        set => field = value >= 0 ? value : field;
    }

    private int FilterDepthForwards
    {
        get;
        set => field = value >= 0 ? value : field;
    }
    
    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender) return;
        if (InitialStepId is not { } filterStepId) return;
        _filterNodeId = filterStepId.ToString();
        StateHasChanged();
    }

    private Task SetDirectionAsync(DependencyGraphDirection direction)
    {
        if (_direction == direction)
        {
            return Task.CompletedTask;
        }
        _direction = direction;
        return LoadGraphAsync();
    }

    private async Task LoadGraphAsync()
    {
        ArgumentNullException.ThrowIfNull(Job);
        ArgumentNullException.ThrowIfNull(Steps);
        ArgumentNullException.ThrowIfNull(_dependencyGraph);
        
        var stepNodes = Steps.Select(INode (step) =>
        {
            var node = new DependencyGraphNode(
                Id: step.StepId.ToString(),
                Name: step.StepName ?? "",
                CssClass: $"{(step.IsEnabled ? "enabled" : "disabled")} internal {(_filterNodeId == step.StepId.ToString() ? "selected" : null)}",
                TooltipText: step.StepType.ToString(),
                EnableOnClick: true
            );
            return new StepNode(step.StepId.ToString(), step.StepName ?? "", node, step);
        });
        
        var uris = Steps
            .SelectMany(step => step.DataObjects)
            .Select(d => d.DataObject.ObjectUri)
            .Distinct()
            .ToArray();
        
        var dataNodes = uris.Select(INode (uri) =>
        {
            var node = new DependencyGraphNode(
                Id: uri,
                Name: uri,
                CssClass: $"font-monospace internal {(_filterNodeId == uri ? "selected" : null)}",
                TooltipText: "Data object",
                EnableOnClick: true,
                Rounded: false
            );
            return new DataNode(uri, uri, node, uri);
        });

        _graphNodes = stepNodes
            .Concat(dataNodes)
            .ToDictionary(x => x.Id, x => x);

        List<DependencyGraphNode> nodes;
        List<DependencyGraphEdge> edges;
        if (_filterNodeId is null)
        {
            nodes = _graphNodes.Values.Select(n => n.Node).ToList();
            edges = Steps
                .SelectMany(step =>
                {
                    var sources = step.DataObjects
                        .Where(d => d.ReferenceType == DataObjectReferenceType.Source)
                        .Select(s => new DependencyGraphEdge(
                            Id: step.StepId.ToString(), DependsOnId: s.DataObject.ObjectUri, CssClass: ""));
                    var targets = step.DataObjects
                        .Where(d => d.ReferenceType == DataObjectReferenceType.Target)
                        .Select(t => new DependencyGraphEdge(
                            Id: t.DataObject.ObjectUri, DependsOnId: step.StepId.ToString(), CssClass: ""));
                    return sources.Concat(targets);
                })
                .Concat(
                    // Add wildcard matches between data objects.
                    uris.SelectMany(u1 =>
                            uris
                                .Select(u2 => (u1, u2))
                                .Where(tuple => tuple.u1 != tuple.u2 && IDataObject.UriIsPartOf(tuple.u1, tuple.u2)))
                        .Select(tuple => new DependencyGraphEdge(
                            Id: tuple.u1, DependsOnId: tuple.u2, CssClass: "")))
                .ToList();
        }
        else
        {
            var filterNode = _graphNodes.GetValueOrDefault(_filterNodeId);
            if (filterNode is null) return;
            
            var iNodes = RecurseDependenciesBackward(filterNode, _graphNodes.Values, [], 0);
            // Separate processed nodes from the rest of the added nodes such that
            // only StepNodes are included in the list of processed.
            // Also remove filter node so that forward recursion can be started from it.
            // This way DataNodes can be processed twice, once for each direction, thus handling URI wildcard matches.
            var processedNodes = iNodes.Where(n => n != filterNode).OfType<StepNode>().Cast<INode>().ToHashSet();
            iNodes = RecurseDependenciesForward(filterNode, _graphNodes.Values, processedNodes, iNodes, 0);
            nodes = iNodes.Select(n => n.Node).ToList();
            edges = Steps
                .SelectMany(step =>
                {
                    var sources = step.DataObjects
                        .Where(d => d.ReferenceType == DataObjectReferenceType.Source)
                        .Where(d => iNodes.Any(n => n.Id == d.DataObject.ObjectUri) && iNodes.Any(n => n.Id == d.StepId.ToString()))
                        .Select(s => new DependencyGraphEdge(
                            Id: step.StepId.ToString(), DependsOnId: s.DataObject.ObjectUri, CssClass: ""));
                    var targets = step.DataObjects
                        .Where(d => d.ReferenceType == DataObjectReferenceType.Target)
                        .Where(d => iNodes.Any(n => n.Id == d.DataObject.ObjectUri) && iNodes.Any(n => n.Id == d.StepId.ToString()))
                        .Select(t => new DependencyGraphEdge(
                            Id: t.DataObject.ObjectUri, DependsOnId: step.StepId.ToString(), CssClass: ""));
                    return sources.Concat(targets);
                })
                .Concat(
                    // Add wildcard matches between data objects.
                    iNodes.OfType<DataNode>().SelectMany(dn1 =>
                        iNodes.OfType<DataNode>()
                                .Select(dn2 => ((IDataObject)dn1, (IDataObject)dn2))
                                .Where(tuple => !tuple.Item1.UriEquals(tuple.Item2) && tuple.Item1.UriIsPartOf(tuple.Item2)))
                        .Select(tuple => new DependencyGraphEdge(
                            Id: tuple.Item1.ObjectUri, DependsOnId: tuple.Item2.ObjectUri, CssClass: "")))
                .ToList();
        }

        await _dependencyGraph.DrawAsync(nodes, edges, _direction);
    }

    private HashSet<INode> RecurseDependenciesBackward(INode node, IReadOnlyCollection<INode> allNodes, 
        HashSet<INode> processedNodes, int depth)
    {
        ArgumentNullException.ThrowIfNull(Steps);

        if (processedNodes.Contains(node) ||
            depth++ > FilterDepthBackwards && FilterDepthBackwards > 0)
        {
            return processedNodes;
        }

        _ = processedNodes.Add(node);

        var dependencyNodes = node switch
        {
            StepNode step => allNodes
                .OfType<DataNode>()
                .Where(dn => step.Step.DataObjects.Any(d => d.ReferenceType == DataObjectReferenceType.Source &&
                                                            d.DataObject.UriEquals(dn)))
                .Cast<INode>()
                .ToList(),
            DataNode data => allNodes
                .OfType<StepNode>()
                .Where(sn => sn.Step.DataObjects.Any(d => d.ReferenceType == DataObjectReferenceType.Target &&
                                                          d.DataObject.UriEquals(data)))
                .Cast<INode>()
                .Concat(
                    // Add wildcard matches between data objects.
                    allNodes.OfType<DataNode>()
                        .Where(dn => dn.ObjectUri != data.ObjectUri && dn.UriIsPartOf(data)))
                .ToList(),
            _ => []
        };

        // Loop through the dependencies and handle them recursively.
        foreach (var dependencyNode in dependencyNodes)
        {
            RecurseDependenciesBackward(dependencyNode, allNodes, processedNodes, depth);
        }

        return processedNodes;
    }

    private HashSet<INode> RecurseDependenciesForward(INode node, IReadOnlyCollection<INode> allNodes,
        HashSet<INode> processedNodes, HashSet<INode> nodes, int depth)
    {
        ArgumentNullException.ThrowIfNull(Steps);

        if (processedNodes.Contains(node) || depth++ > FilterDepthForwards && FilterDepthForwards > 0)
        {
            return nodes;
        }

        _ = processedNodes.Add(node);
        _ = nodes.Add(node);

        var dependencyNodes = node switch
        {
            StepNode step => allNodes
                .OfType<DataNode>()
                .Where(dn => step.Step.DataObjects.Any(d => d.ReferenceType == DataObjectReferenceType.Target &&
                                                            d.DataObject.UriEquals(dn)))
                .Cast<INode>()
                .ToList(),
            DataNode data => allNodes
                .OfType<StepNode>()
                .Where(sn => sn.Step.DataObjects.Any(d => d.ReferenceType == DataObjectReferenceType.Source &&
                                                          d.DataObject.UriEquals(data)))
                .Cast<INode>()
                .Concat(
                    // Add wildcard matches between data objects.
                    allNodes.OfType<DataNode>()
                        .Where(dn => dn.ObjectUri != data.ObjectUri && dn.UriIsPartOf(data)))
                .ToList(),
            _ => []
        };

        foreach (var dependencyNode in dependencyNodes)
        {
            RecurseDependenciesForward(dependencyNode, allNodes, processedNodes, nodes, depth);
        }

        return nodes;
    }

    private Task<AutosuggestDataProviderResult<INode>> ProvideSuggestionsAsync(AutosuggestDataProviderRequest request)
    {
        return Task.FromResult(new AutosuggestDataProviderResult<INode>
        {
            Data = _graphNodes.Values.Where(n => n.Name.ContainsIgnoreCase(request.UserInput))
        });
    }

    private interface INode
    {
        public string Id { get; }

        public string Name { get; }

        public DependencyGraphNode Node { get; }
    }

    private record StepNode(string Id, string Name, DependencyGraphNode Node, Step Step) : INode;

    private record DataNode(string Id, string Name, DependencyGraphNode Node, string ObjectUri) : INode, IDataObject
    {
        public bool UriIsPartOf(IDataObject? other) => IDataObject.UriIsPartOf(this, other);
    }
}
