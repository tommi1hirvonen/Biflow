using Biflow.Ui.Icons;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml.Linq;

namespace Biflow.Ui.SourceGeneration;

[Generator]
internal sealed class IconSourceGenerator : IIncrementalGenerator
{
    private static readonly AssemblyName AssemblyName = typeof(IconSourceGenerator).Assembly.GetName();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: typeof(GenerateIconsAttribute).FullName!,
                predicate: (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax,
                transform: Transform)
            .Collect();

        var icons = context.AdditionalTextsProvider
            .Where(text => text.Path.EndsWith(".svg"))
            .Select((text, cancellationToken) => new IconData(text.Path, text.GetText(cancellationToken)?.ToString()))
            .Collect();
        
        context.RegisterSourceOutput(classes.Combine(icons), GenerateCode);
    }

    private static IconsClassData? Transform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var generateIconsAttribute =
            context.Attributes.FirstOrDefault(a => a.AttributeClass?.Name == nameof(GenerateIconsAttribute)); 
        if (generateIconsAttribute is null)
        {
            return null;
        }
        
        var cssClass = generateIconsAttribute.ConstructorArguments[0].Value?.ToString();
        var pathSegments = generateIconsAttribute.ConstructorArguments[1].Values
            .Select(v => v.Value?.ToString())
            .ToArray();
        var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;
        var @namespace = classDeclaration.GetNamespace();
        var hasRequiredModifiers = classDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword)
                                   && classDeclaration.Modifiers.Any(SyntaxKind.StaticKeyword)
                                   && classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword);
        return new IconsClassData(
            @namespace: @namespace,
            className: context.TargetSymbol.Name,
            cssClass: cssClass,
            pathSegments: pathSegments,
            incorrectModifiers: !hasRequiredModifiers,
            location: context.TargetSymbol.Locations.FirstOrDefault());
    }

    private static void GenerateCode(SourceProductionContext context, (ImmutableArray<IconsClassData?> Left, ImmutableArray<IconData> Right) tuple)
    {
        var (classes, icons) = tuple;
        foreach (var classData in classes.OfType<IconsClassData>())
        {
            if (classData.IncorrectModifiers)
            {
                var diagnostic = Diagnostic.Create(DiagnosticDescriptors.IncorrectModifiers, classData.Location, classData.ClassName);
                context.ReportDiagnostic(diagnostic);
                continue;
            }
            var sourceBuilder = new StringBuilder($$"""
                // <auto-generated/>
                using {{typeof(Svg).Namespace}};

                namespace {{classData.Namespace}};
                
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{AssemblyName.Name}}", "{{AssemblyName.Version}}")]
                public static partial class {{classData.ClassName}}
                {

                """);

            foreach (var iconData in icons.Where(g => g.IconPath.Contains(classData.IconsPath)))
            {
                if (iconData.IconText is null)
                {
                    continue;
                }
                
                var propertyName = iconData.IconName.GetPropertyNameFromIconName();
        
                var xml = XDocument.Parse(iconData.IconText);
                if (classData.CssClass is { Length: > 0 } cssClass)
                {
                    if (xml.Root?.Attributes("class").FirstOrDefault() is { } attr)
                    {
                        attr.Value = string.Join(" ", cssClass.Split(' ').Union(attr.Value.Split(' ')));
                    }
                    else
                    {
                        xml.Root?.Add(new XAttribute("class", classData.CssClass));
                    }
                }

                sourceBuilder.AppendLine($"""""""
                    public static {nameof(Svg)} {propertyName} => new {nameof(Svg)}(""""""
                    {xml}
                    """""");

                    """"""");
            }

            sourceBuilder.Append("}");
            
            context.AddSource($"{classData.ClassName}.g.cs", sourceBuilder.ToString());
        }
    }
}